/* Generated By:JavaCC: Do not edit this line. AnalsisLexico.java */
package Practica2;
import java.io.*;
import Practica2.Simbolo.tipo_variable;
import Practica2.Simbolo.clase_parametro;
import Practica2.Simbolo.tipo_simbolo;
import java.util.ArrayList;

public class AnalsisLexico implements AnalsisLexicoConstants {
  static Tabla_simbolos tablaSim = new Tabla_simbolos();

  static int nivel;

  static int dir = 3;

  static int peso = 0;

  static int etiqueta = - 1;

  static final int INICIAL = 3; /* 3- Encabezamiento  estatico, encabezamiento dinamico, direccion de retorno */

  public static void main(String args []) throws ParseException
  {
    AnalsisLexico parser = null;
    if (args.length == 0)
    {
      System.out.println("Uso: java AnalisisLexico fichero.c");
      System.exit(0);
    }
    try
    {
      parser = new AnalsisLexico(new FileInputStream(args [0]));
      tablaSim.inicializar_tabla();
      nivel = 0;
      parser.entrada();
      System.out.println("Analisis terminado");
      System.out.println("No se han encontrado errores");
    }
    catch (Exception e)
    {
      System.out.println("NOK.");
      System.out.println(e.getMessage());
      e.printStackTrace();
      AnalsisLexico.ReInit(System.in);
    }
    catch (Error e)
    {
      SimpleCharStream stream = parser.jj_input_stream;
      System.out.println("ERROR LEXICO (" + stream.getBeginLine() + "," + stream.getBeginColumn() + ") :simbolo no reconocido: " + stream.GetImage());
    }
  }

  void skipToSaltoLinea()
  {
    Token tok;
    while (true)
    {
      tok = getToken(1);
      if (tok.image.equals("\u005cn"))
      {
        break;
      }
      tok = getNextToken();
    }
  }

  static void errorSemantico(String text)
  {
    System.out.println(text);
  }

  /** * Metodo auxiliar para  centralizar la escritura de codigo **/
  public static void generarCodigo(String text)
  {
    System.out.println(text);
  }

  public static void generarCodigo(ArrayList < String > text)
  {
    for (int i = 0; i < text.size(); i++)
    {
      System.out.println(text.get(i));
    }
  }

  /** * Metodo auxiliar que devuelve el tamaño de tipo_variable **/
  public static int tamanio(tipo_variable tipo)
  {
    if (tipo == tipo_variable.ENTERO)
    {
      return 2;
    }
    else if (tipo == tipo_variable.BOOLEANO)
    {
      return 1;
    }
    else if (tipo == tipo_variable.CARACTER)
    {
      return 1;
    }
    else
    {
      return 2;
    }
  }

  /** * Inicializa la escritura en fichero externo **/
  public static void inicializar_generacion_codigo()
  {}

  /** * Genera una nueva etiqueta */
  public static String nueva_etiqueta()
  {
    etiqueta++;
    return "L" + etiqueta + ":";
  }

  static final public Token entrada() throws ParseException {
  Token tk;
  String etiq;
  ArrayList < String > cacciones, cbloqueinstr;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tPROGRAMA:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      jj_consume_token(tPROGRAMA);
      etiq = nueva_etiqueta();
      generarCodigo("ENP " + etiq);
      tk = jj_consume_token(tIDENTIFICADOR);
      jj_consume_token(49);
      declaracion_variables();
      declaracion_acciones();
      generarCodigo(etiq);
      bloque_sentencias();
      /*
      generarCodigo(cacciones);
      generarCodigo("; Comienzo de " + tk.image);
      generarCodigo(etiq + ":");
      generarCodigo(cbloqueinstr);
      generarCodigo("; Fin de " + tk.image);   
      */
      generarCodigo("LVP");
      jj_consume_token(tFINPROGRAMA);
      {if (true) return tk;}
    }
    jj_consume_token(0);
    throw new Error("Missing return statement in function");
  }

  static final public Token declaracion_variables() throws ParseException {
  Token tk = null;
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tENTERO:
      case tBOOLEANO:
      case tCARACTER:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
      declaracion();
      jj_consume_token(49);
    }
    {if (true) return tk;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList < String > declaracion_acciones() throws ParseException {
  ArrayList < String > tk = null;
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tACCION:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_3;
      }
      declaracion_accion();
    }
    {if (true) return tk;}
    throw new Error("Missing return statement in function");
  }

  static final public Token declaracion_accion() throws ParseException {
  Token tk = null;
  String etiq;
    cabecera_accion();
    jj_consume_token(49);
    declaracion_variables();
    declaracion_acciones();
      etiq = nueva_etiqueta();
      generarCodigo(etiq);
    bloque_sentencias();
    tablaSim.eliminarNivel(nivel);
    nivel--;
    generarCodigo("CSF");
    {if (true) return tk;}
    throw new Error("Missing return statement in function");
  }

/*	declaracion ::= tipo_variables  identificadores*/
  static final public void declaracion() throws ParseException {
  tipo_variable tipoVar;
    tipoVar = tipo_variables();
    identificadores(tipoVar);
  }

/*    identificadores ::= <identificador> (“,” <identificador>)* */
  static final public void identificadores(tipo_variable tipo) throws ParseException {
  Token t1, t2 = null;
    t1 = jj_consume_token(tIDENTIFICADOR);
      if (tablaSim.introducir_variable(t1.image, tipo, nivel, dir) == null)
      {
        errorSemantico("Variable duplicada [" + t1.beginLine + "," + t1.beginColumn + "] " + "Token: <" + t1.image + ">");
      }
      else
      {
        dir = dir + 1;
        peso = peso + tamanio(tipo);
      }
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 50:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_4;
      }
      jj_consume_token(50);
      t2 = jj_consume_token(tIDENTIFICADOR);
        if (tablaSim.introducir_variable(t2.image, tipo, nivel, dir) == null)
        {
          errorSemantico("Variable duplicada [" + t2.beginLine + "," + t2.beginColumn + "] " + "Token: <" + t2.image + ">");
        }
        else
        {
          dir = dir + 1;
          peso = peso + tamanio(tipo);
        }
    }
  }

  static final public ArrayList < String > bloque_sentencias() throws ParseException {
  ArrayList < String > tk = null;
    jj_consume_token(tPRINCIPIO);
    lista_sentencias(false);
    jj_consume_token(tFIN);
    {if (true) return tk;}
    throw new Error("Missing return statement in function");
  }

  static final public Token cabecera_accion() throws ParseException {
  Token tk = null;
  Simbolo s = null;
  boolean ok = false;
  ArrayList < Simbolo > listadoparametros;
    jj_consume_token(tACCION);
    tk = jj_consume_token(tIDENTIFICADOR);
      s = tablaSim.buscar_simbolo(tk.image);
      if (s == null || s.getNivel() != nivel)
      {
        s = tablaSim.introducir_accion(tk.image, nivel, etiqueta + 1);
        ok = true;
      }
      else
      {
        errorSemantico("Accion duplicada [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
      }
      nivel++;
      dir = INICIAL;
      peso = 0;
    listadoparametros = parametros_formales();
      if (s != null)
      {
        s.setListaParametros(listadoparametros);
      }
    {if (true) return tk;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList < Simbolo > parametros_formales() throws ParseException {
  ArrayList < Simbolo > listaformal = new ArrayList < Simbolo > ();
  ArrayList < Simbolo > listaAuxiliar1;
  ArrayList < Simbolo > listaAuxiliar2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 51:
      jj_consume_token(51);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tVAL:
      case tREF:
        listaAuxiliar1 = parametros();
          listaformal.addAll(listaAuxiliar1);
        label_5:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 49:
            ;
            break;
          default:
            jj_la1[4] = jj_gen;
            break label_5;
          }
          jj_consume_token(49);
          listaAuxiliar2 = parametros();
            listaformal.addAll(listaAuxiliar2);
        }
        break;
      default:
        jj_la1[5] = jj_gen;
        ;
      }
      jj_consume_token(52);
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    {if (true) return listaformal;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList < Simbolo > parametros() throws ParseException {
  clase_parametro tkclase = null;
  tipo_variable tktipo = null;
  ArrayList < Simbolo > listaglobal;
    tkclase = clase_parametros();
    tktipo = tipo_variables();
    listaglobal = lista_parametros(tktipo, tkclase);
    {if (true) return listaglobal;}
    throw new Error("Missing return statement in function");
  }

  static final public clase_parametro clase_parametros() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tVAL:
      jj_consume_token(tVAL);
      {if (true) return clase_parametro.VAL;}
      break;
    case tREF:
      jj_consume_token(tREF);
      {if (true) return clase_parametro.REF;}
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList < Simbolo > lista_parametros(tipo_variable tipo, clase_parametro clase) throws ParseException {
  Token t1, t2 = null;
  Simbolo s1, s2;
  ArrayList < Simbolo > lista = new ArrayList < Simbolo > ();
    t1 = jj_consume_token(tIDENTIFICADOR);
      s1 = tablaSim.introducir_parametro(t1.image, tipo, clase, nivel, dir);
      lista.add(s1);
      if (s1 == null)
      {
        errorSemantico("Identificador duplicado [" + t1.beginLine + "," + t1.beginColumn + "] " + "Token: <" + t1.image + ">");
      }
      else
      {
        dir = dir + tamanio(tipo);
      }
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 50:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_6;
      }
      jj_consume_token(50);
      t2 = jj_consume_token(tIDENTIFICADOR);
        s2 = tablaSim.introducir_parametro(t2.image, tipo, clase, nivel, dir);
        lista.add(s2);
        if (s2 == null)
        {
          errorSemantico("Identificador duplicado [" + t2.beginLine + "," + t2.beginColumn + "] " + "Token: <" + t2.image + ">");
        }
        else
        {
          dir = dir + tamanio(tipo);
        }
    }
    {if (true) return lista;}
    throw new Error("Missing return statement in function");
  }

  static final public Token lista_sentencias(boolean estado) throws ParseException {
  Token tk = null;
    label_7:
    while (true) {
      sentencia(estado);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tSI:
      case tMQ:
      case tESCRIBIR:
      case tLEER:
      case tIDENTIFICADOR:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_7;
      }
    }
    {if (true) return tk;}
    throw new Error("Missing return statement in function");
  }

  static final public Token sentencia(boolean estado) throws ParseException {
  Token tk = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tLEER:
      leer();
      jj_consume_token(49);
      break;
    case tESCRIBIR:
      escribir(estado);
      jj_consume_token(49);
      break;
    case tIDENTIFICADOR:
      asignacion(estado);
      break;
    case tSI:
      seleccion(estado);
      break;
    case tMQ:
      mientras_que();
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return tk;}
    throw new Error("Missing return statement in function");
  }

  static final public tipo_variable tipo_variables() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tENTERO:
      jj_consume_token(tENTERO);
      {if (true) return tipo_variable.ENTERO;}
      break;
    case tCARACTER:
      jj_consume_token(tCARACTER);
      {if (true) return tipo_variable.CARACTER;}
      break;
    case tBOOLEANO:
      jj_consume_token(tBOOLEANO);
      {if (true) return tipo_variable.BOOLEANO;}
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*leer::=  <tLEER> "(" <tIDENTIFICADOR> ( "," < tIDENTIFICADOR >  )* ")"*/
  static final public void leer() throws ParseException {
  Token t1, t2 = null;
  Simbolo s1, s2;
    jj_consume_token(tLEER);
    jj_consume_token(51);
    t1 = jj_consume_token(tIDENTIFICADOR);
        s1 = tablaSim.buscar_simbolo(t1.image);
        if (s1 == null)
        {
          errorSemantico("No existe variable [" + t1.beginLine + "," + t1.beginColumn + "] " + "Token: <" + t1.image + ">");
        }
        else if ((s1.getTipo() == tipo_simbolo.PARAMETRO) && (s1.getParametro() == clase_parametro.VAL))
        {
          errorSemantico("Leer tiene que recibir un parametro por referencia [" + t1.beginLine + "," + t1.beginColumn + "] " + "Token: <" + t1.image + ">");
        }
        else
        {
          RegistroFactor auxi = s1.getFactor();
          if (auxi != null)
          {
            auxi.constante = false;
            s1.setFactor(auxi);
          }
          generarCodigo("SRF " + (nivel - s1.getNivel()) + " " + s1.getDir());
          if (s1.getVariable() == tipo_variable.ENTERO)
          {
            generarCodigo("RD 1");
          }
          else
          {
            generarCodigo("RD 0");
          }
        }
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 50:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_8;
      }
      jj_consume_token(50);
      t2 = jj_consume_token(tIDENTIFICADOR);
          s2 = tablaSim.buscar_simbolo(t2.image);
          if (s2 == null)
          {
            errorSemantico("No existe variable [" + t2.beginLine + "," + t2.beginColumn + "] " + "Token: <" + t2.image + ">");
          }
          else if ((s2.getTipo() == tipo_simbolo.PARAMETRO) && (s2.getParametro() == clase_parametro.VAL))
          {
            errorSemantico("Leer tiene que recibir un parametro por referencia [" + t2.beginLine + "," + t2.beginColumn + "] " + "Token: <" + t2.image + ">");
          }
          else
          {
            RegistroFactor auxi = s2.getFactor();
            if (auxi != null)
            {
              auxi.constante = false;
              s1.setFactor(auxi);
            }
            generarCodigo("SRF " + (nivel - s2.getNivel()) + " " + s2.getDir());
            if (s2.getVariable() == tipo_variable.ENTERO)
            {
              generarCodigo("RD 1");
            }
            else
            {
              generarCodigo("RD 0");
            }
          }
    }
    jj_consume_token(52);
  }

  static final public Token escribir(boolean estado) throws ParseException {
  Token tk = null;
    tk = jj_consume_token(tESCRIBIR);
    jj_consume_token(51);
    lista_escribibles(tk,estado);
    jj_consume_token(52);
    {if (true) return tk;}
    throw new Error("Missing return statement in function");
  }

/*	asignacion ::= < tIDENTIFICADOR > ( < tOPAS > expresion | argumentos )? ";"*/
  static final public void asignacion(boolean estado) throws ParseException {
  Token tk = null;
  Simbolo s1;
  boolean esAccion = true;
  RegistroFactor expre;
  ArrayList < RegistroFactor > lista = null;
    tk = jj_consume_token(tIDENTIFICADOR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tOPAS:
    case 51:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tOPAS:
        jj_consume_token(tOPAS);
        expre = expresion(estado);
        esAccion = false;
        s1 = tablaSim.buscar_simbolo(tk.image);
        if (s1 == null)
        {
          errorSemantico("No existe variable [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
        }
        else if ((s1.getTipo() == tipo_simbolo.PARAMETRO) && (s1.getParametro() == clase_parametro.VAL))
        {
          errorSemantico("Parametro por valor en la parte izquierda de la asignacion [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
        }
        else if (expre.constante)
        {
          // SRF 0 s1.getDir()
          generarCodigo("SRF " + (nivel - s1.getNivel()) + " " + s1.getDir());
          if (estado)
          {
            expre.constante = false;
            s1.setFactor(expre);
          }
          else s1.setFactor(expre);
          if (expre.tipo == tipo_variable.ENTERO)
          { //STC expre.valorEnt;
            generarCodigo("STC " + expre.valorEnt);
          }
          else if (expre.tipo == tipo_variable.BOOLEANO)
          { //STC expre.valorBool;
            if (expre.valorBool)
            {
              generarCodigo("STC 1");
            }
            else
            {
              generarCodigo("STC 0");
            }
          }
          else if (expre.tipo == tipo_variable.CARACTER)
          { //STC expre.valorChar;
            generarCodigo("STC " + (int) expre.valorChar);
          }
          //ASG
          generarCodigo("ASG");
        }
        else
        {
          s1.setFactor(expre);
          // SRF 0 s1.getDir()
          generarCodigo("SRF " + (nivel - s1.getNivel()) + " " + s1.getDir());
          //expre.listado
          generarCodigo(expre.listado);
          //ASG
          generarCodigo("ASG");
        }
        break;
      case 51:
        lista = argumentos();
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
      if (esAccion)
      {
        s1 = tablaSim.buscar_simbolo(tk.image);
        if ((s1 == null) || (s1.getTipo() != tipo_simbolo.ACCION))
        {
          errorSemantico("No existe accion [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
        }
        else if (s1.getListaParametros().size() != 0)
        {
          if ((lista == null) && (s1.getListaParametros().size() > 0))
          {
            errorSemantico("Se esperaban mas parametros [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
          }
          else if (lista.size() != s1.getListaParametros().size())
          {
            errorSemantico("Numero de parametros incorrecto [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
          }
          else
          {
            for (int i = 0; i < lista.size(); i++)
            {
              if (lista.get(i).tipo != s1.getListaParametros().get(i).getVariable())
              {
                errorSemantico("Parametro incorrecto se esperaba " + lista.get(i).tipo + "[" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
              }
              else if ((!lista.get(i).variable && s1.getListaParametros().get(i).getParametro() == clase_parametro.REF) || ((lista.get(i).par == clase_parametro.VAL) && (s1.getListaParametros().get(i).getParametro() == clase_parametro.REF)))
              {
                errorSemantico("Un parametro recibido por valor no se puede pasar por referencias " + lista.get(i).tipo + "[" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
              }
              else if (lista.get(i).constante && !lista.get(i).variable)
              {
                expre = lista.get(i);
                if (expre.tipo == tipo_variable.ENTERO)
                { //STC expre.valorEnt;
                  generarCodigo("STC " + expre.valorEnt);
                }
                else if (expre.tipo == tipo_variable.BOOLEANO)
                { //STC expre.valorBool;
                  if (expre.valorBool)
                  {
                    generarCodigo("STC 1");
                  }
                  else
                  {
                    generarCodigo("STC 0");
                  }
                }
                else if (expre.tipo == tipo_variable.CARACTER)
                { //STC expre.valorChar;
                  generarCodigo("STC " + (int) expre.valorChar);
                }
              }
              else if (lista.get(i).variable && lista.get(i).par == clase_parametro.REF)
              {
                generarCodigo(lista.get(i).listado.get(0));
              }
              else
              {
                generarCodigo(lista.get(i).listado);
              }
            }
          }
        }
        //OSF nivel l a 
        generarCodigo("OSF " + peso + " " + nivel + " L" + s1.getDir() + ":");
      }
    jj_consume_token(49);
  }

  static final public Token mientras_que() throws ParseException {
  RegistroFactor term = null;
  Token tk = null;
  String etqMQ, etqFIN;
    tk = jj_consume_token(tMQ);
      etqMQ = nueva_etiqueta();
      generarCodigo(etqMQ);
    term = expresion(true);
      {
        if ((term.tipo != tipo_variable.DESCONOCIDO) && (term.tipo != tipo_variable.BOOLEANO))
        {
          errorSemantico("La condici\u00f3n en el mientras_que debe ser un booleano [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
        }
      }
      if (term.constante)
      { //warning o error
        errorSemantico("ERRORR");
      }
      else
      {
        generarCodigo(term.listado);
      }
      etqFIN = nueva_etiqueta();
      generarCodigo("JMF " + etqFIN);
    lista_sentencias(true);
    jj_consume_token(tFMQ);
      generarCodigo("JMP " + etqMQ);
      generarCodigo(etqFIN);
    {if (true) return tk;}
    throw new Error("Missing return statement in function");
  }

  static final public Token seleccion(boolean estado) throws ParseException {
  RegistroFactor term = null;
  Token tk = null;
  String etqSINO, etqFIN;
  boolean sino = false;
    tk = jj_consume_token(tSI);
    term = expresion(estado);
      if ((term.tipo != tipo_variable.DESCONOCIDO) && (term.tipo != tipo_variable.BOOLEANO))
      {
        errorSemantico("La condici\u00f3n en el si debe ser un booleano [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
      }
      if (term.constante)
      { //warning o error
        errorSemantico("ERRORR");
      }
      else
      {
        generarCodigo(term.listado);
      }
      etqSINO = nueva_etiqueta();
      generarCodigo("JMF " + etqSINO);
    jj_consume_token(tENT);
    lista_sentencias(true);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tSI_NO:
      jj_consume_token(tSI_NO);
        sino = true;
        etqFIN = nueva_etiqueta();
        generarCodigo("JMP " + etqFIN);
        generarCodigo(etqSINO);
      lista_sentencias(true);
        generarCodigo(etqFIN);
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
      if (!sino)
      {
        generarCodigo(etqSINO);
      }
    jj_consume_token(tFSI);
    {if (true) return tk;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList < RegistroFactor > argumentos() throws ParseException {
  ArrayList < RegistroFactor > lista = null;
    jj_consume_token(51);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tNOT:
    case tTRUE:
    case tFALSE:
    case tENTACAR:
    case tCARAENT:
    case tCONSTENTERA:
    case tCONSTCHAR:
    case tCONSTCAD:
    case tIDENTIFICADOR:
    case 51:
      lista = lista_expresiones(false);
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    jj_consume_token(52);
    {if (true) return lista;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList < RegistroFactor > lista_expresiones(boolean estado) throws ParseException {
  ArrayList < RegistroFactor > lista = new ArrayList < RegistroFactor > ();
  RegistroFactor term1, term2 = null;
    term1 = expresion(estado);
      lista.add(term1);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 50:
        ;
        break;
      default:
        jj_la1[17] = jj_gen;
        break label_9;
      }
      jj_consume_token(50);
      term2 = expresion(estado);
        {
          lista.add(term2);
        }
    }
    {if (true) return lista;}
    throw new Error("Missing return statement in function");
  }

/* expresion::= expresion_simple ( operador_relacional expresion_simple )?*/
  static final public RegistroFactor expresion(boolean estado) throws ParseException {
  RegistroFactor term1, term2 = null;
  RegistroFactor terfin = null;
  Token tk = null;
    term1 = expresion_simple(estado);
      terfin = term1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tMAYOR:
    case tMENOR:
    case tIGUAL:
    case tMAI:
    case tMEI:
    case tNI:
      tk = operador_relacional();
      term2 = expresion_simple(estado);
        terfin = new RegistroFactor();
        if ((term1.tipo != tipo_variable.DESCONOCIDO) && (term2.tipo != tipo_variable.DESCONOCIDO) && (term1.tipo != term2.tipo))
        {
          errorSemantico("Los operandos deben ser del mismo tipo [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
          terfin.tipo = tipo_variable.DESCONOCIDO;
          terfin.constante = false;
        }
        else if ((term1.tipo != tipo_variable.DESCONOCIDO) && (term2.tipo != tipo_variable.DESCONOCIDO) && (term1.tipo == term2.tipo)) //AMBOS OPERANDOS DEL MISMO TIPO 
        {
          if (tk.image.equals(">"))
          {
            if (term1.tipo != tipo_variable.ENTERO && term1.tipo != tipo_variable.CARACTER)
            {
              errorSemantico("Error en operador relacional, se esperaba ENTERO O CARACTER[" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
            }
            else if (term1.constante && term2.constante && !estado)
            {
              terfin.constante = true;
              terfin.tipo = tipo_variable.BOOLEANO;
              if (term1.tipo == tipo_variable.ENTERO)
              {
                terfin.valorBool = term1.valorEnt > term2.valorEnt;
              }
              else
              {
                terfin.valorBool = term1.valorChar > term2.valorChar;
              }
            }
            else if (term1.constante && !estado) //term2 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              if (term1.tipo == tipo_variable.ENTERO)
              {
                auxilar.add("STC " + term1.valorEnt);
              }
              else
              {
                auxilar.add("STC " + (int) term1.valorChar);
              }
              auxilar.addAll(term2.listado);
              auxilar.add("GT");
              terfin.listado = auxilar;
            }
            else if (term2.constante && !estado) //term1 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              if (term1.tipo == tipo_variable.ENTERO)
              {
                auxilar.add("STC " + term2.valorEnt);
              }
              else
              {
                auxilar.add("STC " + (int) term2.valorChar);
              }
              auxilar.add("GT");
              terfin.listado = auxilar;
            }
            else //term1 y term 2 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              auxilar.addAll(term2.listado);
              auxilar.add("GT");
              terfin.listado = auxilar;
            }
          }
          else if (tk.image.equals("<"))
          {
            if (term1.tipo != tipo_variable.ENTERO && term1.tipo != tipo_variable.CARACTER)
            {
              errorSemantico("Error en operador relacional, se esperaba ENTERO O CARACTER[" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
            }
            else if (term1.constante && term2.constante && !estado)
            {
              terfin.constante = true;
              terfin.tipo = tipo_variable.BOOLEANO;
              if (term1.tipo == tipo_variable.ENTERO)
              {
                terfin.valorBool = term1.valorEnt < term2.valorEnt;
              }
              else
              {
                terfin.valorBool = term1.valorChar < term2.valorChar;
              }
            }
            else if (term1.constante && !estado) //term2 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              if (term1.tipo == tipo_variable.ENTERO)
              {
                auxilar.add("STC " + term1.valorEnt);
              }
              else
              {
                auxilar.add("STC " + (int) term1.valorChar);
              }
              auxilar.addAll(term2.listado);
              auxilar.add("LT");
              terfin.listado = auxilar;
            }
            else if (term2.constante && !estado) //term1 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              if (term1.tipo == tipo_variable.ENTERO)
              {
                auxilar.add("STC " + term2.valorEnt);
              }
              else
              {
                auxilar.add("STC " + (int) term2.valorChar);
              }
              auxilar.add("LT");
              terfin.listado = auxilar;
            }
            else //term1 y term 2 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              auxilar.addAll(term2.listado);
              auxilar.add("LT");
              terfin.listado = auxilar;
            }
          }
          else if (tk.image.equals("="))
          {
            if (term1.tipo != tipo_variable.ENTERO && term1.tipo != tipo_variable.CARACTER)
            {
              errorSemantico("Error en operador relacional, se esperaba ENTERO O CARACTER[" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
            }
            else if (term1.constante && term2.constante && !estado)
            {
              terfin.constante = true;
              terfin.tipo = tipo_variable.BOOLEANO;
              if (term1.tipo == tipo_variable.ENTERO)
              {
                terfin.valorBool = term1.valorEnt == term2.valorEnt;
              }
              else
              {
                terfin.valorBool = term1.valorChar == term2.valorChar;
              }
            }
            else if (term1.constante && !estado) //term2 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              if (term1.tipo == tipo_variable.ENTERO)
              {
                auxilar.add("STC " + term1.valorEnt);
              }
              else
              {
                auxilar.add("STC " + (int) term1.valorChar);
              }
              auxilar.addAll(term2.listado);
              auxilar.add("EQ");
              terfin.listado = auxilar;
            }
            else if (term2.constante && !estado) //term1 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              if (term1.tipo == tipo_variable.ENTERO)
              {
                auxilar.add("STC " + term2.valorEnt);
              }
              else
              {
                auxilar.add("STC " + (int) term2.valorChar);
              }
              auxilar.add("EQ");
              terfin.listado = auxilar;
            }
            else //term1 y term 2 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              auxilar.addAll(term2.listado);
              auxilar.add("EQ");
              terfin.listado = auxilar;
            }
          }
          else if (tk.image.equals("<="))
          {
            if (term1.tipo != tipo_variable.ENTERO && term1.tipo != tipo_variable.CARACTER)
            {
              errorSemantico("Error en operador relacional, se esperaba ENTERO O CARACTER[" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
            }
            else if (term1.constante && term2.constante && !estado)
            {
              terfin.constante = true;
              terfin.tipo = tipo_variable.BOOLEANO;
              if (term1.tipo == tipo_variable.ENTERO)
              {
                terfin.valorBool = term1.valorEnt <= term2.valorEnt;
              }
              else
              {
                terfin.valorBool = term1.valorChar <= term2.valorChar;
              }
            }
            else if (term1.constante && !estado) //term2 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              if (term1.tipo == tipo_variable.ENTERO)
              {
                auxilar.add("STC " + term1.valorEnt);
              }
              else
              {
                auxilar.add("STC " + (int) term1.valorChar);
              }
              auxilar.addAll(term2.listado);
              auxilar.add("LTE");
              terfin.listado = auxilar;
            }
            else if (term2.constante && !estado) //term1 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              if (term1.tipo == tipo_variable.ENTERO)
              {
                auxilar.add("STC " + term2.valorEnt);
              }
              else
              {
                auxilar.add("STC " + (int) term2.valorChar);
              }
              auxilar.add("LTE");
              terfin.listado = auxilar;
            }
            else //term1 y term 2 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              auxilar.addAll(term2.listado);
              auxilar.add("LTE");
              terfin.listado = auxilar;
            }
          }
          else if (tk.image.equals(">="))
          {
            if (term1.tipo != tipo_variable.ENTERO && term1.tipo != tipo_variable.CARACTER)
            {
              errorSemantico("Error en operador relacional, se esperaba ENTERO O CARACTER[" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
            }
            else if (term1.constante && term2.constante && !estado)
            {
              terfin.constante = true;
              terfin.tipo = tipo_variable.BOOLEANO;
              if (term1.tipo == tipo_variable.ENTERO)
              {
                terfin.valorBool = term1.valorEnt >= term2.valorEnt;
              }
              else
              {
                terfin.valorBool = term1.valorChar >= term2.valorChar;
              }
            }
            else if (term1.constante && !estado) //term2 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              if (term1.tipo == tipo_variable.ENTERO)
              {
                auxilar.add("STC " + term1.valorEnt);
              }
              else
              {
                auxilar.add("STC " + (int) term1.valorChar);
              }
              auxilar.addAll(term2.listado);
              auxilar.add("GTE");
              terfin.listado = auxilar;
            }
            else if (term2.constante && !estado) //term1 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              if (term1.tipo == tipo_variable.ENTERO)
              {
                auxilar.add("STC " + term2.valorEnt);
              }
              else
              {
                auxilar.add("STC " + (int) term2.valorChar);
              }
              auxilar.add("GTE");
              terfin.listado = auxilar;
            }
            else //term1 y term 2 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              auxilar.addAll(term2.listado);
              auxilar.add("GTE");
              terfin.listado = auxilar;
            }
          }
          else if (tk.image.equals("<>"))
          {
            if (term1.tipo != tipo_variable.ENTERO && term1.tipo != tipo_variable.CARACTER)
            {
              errorSemantico("Error en operador relacional, se esperaba ENTERO O CARACTER[" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
            }
            else if (term1.constante && term2.constante && !estado)
            {
              terfin.constante = true;
              terfin.tipo = tipo_variable.BOOLEANO;
              if (term1.tipo == tipo_variable.ENTERO)
              {
                terfin.valorBool = term1.valorEnt != term2.valorEnt;
              }
              else
              {
                terfin.valorBool = term1.valorChar != term2.valorChar;
              }
            }
            else if (term1.constante && !estado) //term2 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              if (term1.tipo == tipo_variable.ENTERO)
              {
                auxilar.add("STC " + term1.valorEnt);
              }
              else
              {
                auxilar.add("STC " + (int) term1.valorChar);
              }
              auxilar.addAll(term2.listado);
              auxilar.add("NEQ");
              terfin.listado = auxilar;
            }
            else if (term2.constante && !estado) //term1 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              if (term1.tipo == tipo_variable.ENTERO)
              {
                auxilar.add("STC " + term2.valorEnt);
              }
              else
              {
                auxilar.add("STC " + (int) term2.valorChar);
              }
              auxilar.add("NEQ");
              terfin.listado = auxilar;
            }
            else //term1 y term 2 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              auxilar.addAll(term2.listado);
              auxilar.add("NEQ");
              terfin.listado = auxilar;
            }
          }
          else
          {
            errorSemantico("Error Supremo(108), Codigo Incorrecto [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
          }
        }
        else if ((term1.tipo == tipo_variable.DESCONOCIDO) && (term2.tipo == tipo_variable.DESCONOCIDO))
        { //LOS 2 DESCONOCIDOS  PETADO NO HACE FALTA GENEAR CODIGO
          terfin.tipo = tipo_variable.DESCONOCIDO;
          terfin.constante = false;
        }
        else
        {
          errorSemantico("Error Supremo(109), Codigo Incorrecto [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
        }
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
      {if (true) return terfin;}
    throw new Error("Missing return statement in function");
  }

  static final public Token lista_escribibles(Token tk,boolean estado) throws ParseException {
  ArrayList < RegistroFactor > lista = null;
    lista = lista_expresiones(estado);
    for (int i = 0; i < lista.size(); i++)
    {
      if (lista.get(i).tipo == tipo_variable.BOOLEANO)
      {
        errorSemantico("No se pueden escribir booleanos [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
      }
      else if (lista.get(i).tipo == tipo_variable.ENTERO)
      {
        if (lista.get(i).constante && !estado)
        {
          generarCodigo("STC " + lista.get(i).valorEnt);
        }
        else
        {
          generarCodigo(lista.get(i).listado);
        }
        generarCodigo("WRT 1");
      }
      else if (lista.get(i).tipo == tipo_variable.CARACTER)
      {
        if (lista.get(i).constante && !estado)
        {
          generarCodigo("STC " + (int) lista.get(i).valorChar);
        }
        else
        {
          generarCodigo(lista.get(i).listado);
        }
        generarCodigo("WRT 0");
      }
      else if (lista.get(i).tipo == tipo_variable.CADENA)
      {
        if (lista.get(i).constante)
        {
          char [ ] c_arr = lista.get(i).valorCadena.toCharArray();
          for (int j = 1; j < c_arr.length - 1; j++)
          {
            generarCodigo("STC " + (int) c_arr [ j ]);
            generarCodigo("WRT 0");
          }
        }
        else
        {
          errorSemantico("Error Supremo(110), Codigo Incorrecto [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
        }
      }
    }
    {if (true) return tk;}
    throw new Error("Missing return statement in function");
  }

/* termino::= factor ( operador_multiplicativo factor )**/
  static final public RegistroFactor termino(boolean estado) throws ParseException {
  RegistroFactor term1, term2 = null;
  RegistroFactor terfin = null;
  Token tk = null;
    term1 = factor(estado);
      terfin = term1;
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIV:
      case MUL:
      case tAND:
      case tMOD:
      case tDIV:
        ;
        break;
      default:
        jj_la1[19] = jj_gen;
        break label_10;
      }
      tk = operador_multiplicativo();
      term2 = factor(estado);
        terfin = new RegistroFactor();
        if ((term1.tipo != tipo_variable.DESCONOCIDO) && (term2.tipo != tipo_variable.DESCONOCIDO) && (term1.tipo != term2.tipo)) //TIPO INCORRECTO
        {
          errorSemantico("Los operandos deben ser del mismo tipo [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
          terfin.tipo = tipo_variable.DESCONOCIDO;
          terfin.constante = false;
        }
        else if ((term1.tipo != tipo_variable.DESCONOCIDO) && (term2.tipo != tipo_variable.DESCONOCIDO) && (term1.tipo == term2.tipo)) //AMBOS OPERANDOS DEL MISMO TIPO 
        {
          if (tk.image.equals("*"))
          {
            if (term1.tipo != tipo_variable.ENTERO)
            {
              errorSemantico("Error en operador multiplicativo, se esperaba ENTERO [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
              terfin.tipo = tipo_variable.ENTERO;
              terfin.constante = false;
            }
            else if (term1.constante && term2.constante && !estado) //ENTERO '*' ENTERO
            {
              terfin.tipo = tipo_variable.ENTERO;
              terfin.valorEnt = term1.valorEnt * term2.valorEnt;
              term1.valorEnt = terfin.valorEnt;
              terfin.constante = true;
            }
            else if (term1.constante && !estado) //term2 valor desconocido
            {
              terfin.tipo = tipo_variable.ENTERO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.add("STC " + term1.valorEnt);
              auxilar.addAll(term2.listado);
              auxilar.add("TMS");
              terfin.listado = auxilar;
              term1.constante = false;
              term1.listado = auxilar;
            }
            else if (term2.constante && !estado) //term1 valor desconocido
            {
              terfin.tipo = tipo_variable.ENTERO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              auxilar.add("STC " + term2.valorEnt);
              auxilar.add("TMS");
              terfin.listado = auxilar;
              term1.listado = auxilar;
            }
            else //term1 y term 2 valor desconocido
            {
              terfin.tipo = tipo_variable.ENTERO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              auxilar.addAll(term2.listado);
              auxilar.add("TMS");
              terfin.listado = auxilar;
              term1.listado = auxilar;
            }
          }
          else if (tk.image.equals("/") || tk.image.equals("div") || tk.image.equals("DIV"))
          {
            if (term1.tipo != tipo_variable.ENTERO)
            {
              errorSemantico("Error en operador multiplicativo, se esperaba ENTERO [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
            }
            else if (term1.constante && term2.constante && !estado) //ENTERO '-' ENTERO
            {
              terfin.valorEnt = term1.valorEnt / term2.valorEnt;
              terfin.tipo = tipo_variable.ENTERO;
              term1.valorEnt = terfin.valorEnt;
              terfin.constante = true;
            }
            else if (term1.constante && !estado) //term2 valor desconocido
            {
              terfin.tipo = tipo_variable.ENTERO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.add("STC " + term1.valorEnt);
              auxilar.addAll(term2.listado);
              auxilar.add("DIV");
              terfin.listado = auxilar;
              term1.constante = false;
              term1.listado = auxilar;
            }
            else if (term2.constante && !estado) //term1 valor desconocido
            {
              terfin.tipo = tipo_variable.ENTERO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              auxilar.add("STC " + term2.valorEnt);
              auxilar.add("DIV");
              terfin.listado = auxilar;
              term1.listado = auxilar;
            }
            else //term1 y term 2 valor desconocido
            {
              terfin.tipo = tipo_variable.ENTERO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              auxilar.addAll(term2.listado);
              auxilar.add("DIV");
              terfin.listado = auxilar;
              term1.listado = auxilar;
            }
          }
          else if (tk.image.equals("mod") || tk.image.equals("MOD"))
          {
            if (term1.tipo != tipo_variable.ENTERO)
            {
              errorSemantico("Error en operador multiplicativo, se esperaba ENTERO [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
            }
            else if (term1.constante && term2.constante && !estado) //ENTERO 'mod' ENTERO
            {
              terfin.valorEnt = term1.valorEnt % term2.valorEnt;
              terfin.tipo = tipo_variable.ENTERO;
              term1.valorEnt = terfin.valorEnt;
              terfin.constante = true;
            }
            else if (term1.constante && !estado) //term2 valor desconocido
            {
              terfin.tipo = tipo_variable.ENTERO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.add("STC " + term1.valorEnt);
              auxilar.addAll(term2.listado);
              auxilar.add("MOD");
              terfin.listado = auxilar;
              term1.constante = false;
              term1.listado = auxilar;
            }
            else if (term2.constante && !estado) //term1 valor desconocido
            {
              terfin.tipo = tipo_variable.ENTERO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              auxilar.add("STC " + term2.valorEnt);
              auxilar.add("MOD");
              terfin.listado = auxilar;
              term1.listado = auxilar;
            }
            else //term1 y term 2 valor desconocido
            {
              terfin.tipo = tipo_variable.ENTERO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              auxilar.addAll(term2.listado);
              auxilar.add("MOD");
              terfin.listado = auxilar;
              term1.listado = auxilar;
            }
          }
          else if (tk.image.equals("and") || tk.image.equals("AND"))
          {
            if (term1.tipo != tipo_variable.BOOLEANO)
            {
              errorSemantico("Error en operador multiplicativo, se esperaba BOOLEANO [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
            }
            else if (term1.constante && term2.constante && !estado) //BOOLEANO 'and' BOOLEANO
            {
              terfin.constante = true;
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.valorBool = term1.valorBool & term2.valorBool;
              term1.valorBool = terfin.valorBool;
            }
            else if (term1.constante && !estado) //term2 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              if (term1.valorBool)
              {
                auxilar.add("STC 1");
              }
              else
              {
                auxilar.add("STC 0");
              }
              auxilar.addAll(term2.listado);
              auxilar.add("AND");
              terfin.listado = auxilar;
              term1.constante = false;
              term1.listado = auxilar;
            }
            else if (term2.constante && !estado) //term1 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              if (term2.valorBool)
              {
                auxilar.add("STC 1");
              }
              else
              {
                auxilar.add("STC 0");
              }
              auxilar.add("AND");
              terfin.listado = auxilar;
              term1.listado = auxilar;
            }
            else //term1 y term 2 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              auxilar.addAll(term2.listado);
              auxilar.add("AND");
              terfin.listado = auxilar;
              term1.listado = auxilar;
            }
          }
          else
          {
            errorSemantico("Error Supremo(106), Codigo Incorrecto [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
          }
        }
        else if ((term1.tipo == tipo_variable.DESCONOCIDO) && (term2.tipo == tipo_variable.DESCONOCIDO))
        { //LOS 2 DESCONOCIDOS  PETADO NO HACE FALTA GENEAR CODIGO
          terfin.tipo = tipo_variable.DESCONOCIDO;
          terfin.constante = false;
        }
        else
        {
          errorSemantico("Error Supremo(107), Codigo Incorrecto [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
        }
    }
      {if (true) return terfin;}
    throw new Error("Missing return statement in function");
  }

/* expresion_simple::= termino ( operador_aditivo termino )**/
  static final public RegistroFactor expresion_simple(boolean estado) throws ParseException {
  RegistroFactor term1, term2 = null;
  RegistroFactor terfin = null;
  Token tk = null;
    term1 = termino(estado);
      terfin = term1;
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MAS:
      case MENOS:
      case tOR:
        ;
        break;
      default:
        jj_la1[20] = jj_gen;
        break label_11;
      }
      tk = operador_aditivo();
      term2 = termino(estado);
        terfin = new RegistroFactor();
        if ((term1.tipo != tipo_variable.DESCONOCIDO) && (term2.tipo != tipo_variable.DESCONOCIDO) && (term1.tipo != term2.tipo)) ////TIPO INCORRECTO
        {
          errorSemantico("Los operandos deben ser del mismo tipo [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
          terfin.tipo = tipo_variable.DESCONOCIDO;
          terfin.constante = false;
        }
        else if ((term1.tipo != tipo_variable.DESCONOCIDO) && (term2.tipo != tipo_variable.DESCONOCIDO) && (term1.tipo == term2.tipo)) //AMBOS OPERANDOS DEL MISMO TIPO 
        {
          if (tk.image.equals("+"))
          {
            if (term1.tipo != tipo_variable.ENTERO)
            {
              errorSemantico("Error en operador aditivo, se esperaba ENTERO [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
              terfin.tipo = tipo_variable.ENTERO;
              terfin.constante = false;
            }
            else if (term1.constante && term2.constante && !estado) //ENTERO '+' ENTERO
            {
              terfin.tipo = tipo_variable.ENTERO;
              terfin.valorEnt = term1.valorEnt + term2.valorEnt;
              term1.valorEnt = terfin.valorEnt;
              terfin.constante = true;
            }
            else if (term1.constante && !estado) //term2 valor desconocido
            {
              terfin.tipo = tipo_variable.ENTERO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.add("STC " + term1.valorEnt);
              auxilar.addAll(term2.listado);
              auxilar.add("PLUS");
              terfin.listado = auxilar;
              term1.listado = auxilar;
              term1.constante = false;
            }
            else if (term2.constante && !estado) //term1 valor desconocido
            {
              terfin.tipo = tipo_variable.ENTERO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              auxilar.add("STC " + term2.valorEnt);
              auxilar.add("PLUS");
              terfin.listado = auxilar;
              term1.listado = auxilar;
            }
            else //term1 y term 2 valor desconocido
            {
              terfin.tipo = tipo_variable.ENTERO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              auxilar.addAll(term2.listado);
              auxilar.add("PLUS");
              terfin.listado = auxilar;
              term1.listado = auxilar;
            }
          }
          else if (tk.image.equals("-"))
          {
            if (term1.tipo != tipo_variable.ENTERO)
            {
              errorSemantico("Error en operador aditivo, se esperaba ENTERO [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
            }
            else if (term1.constante && term2.constante && !estado) //ENTERO '-' ENTERO
            {
              terfin.valorEnt = term1.valorEnt - term2.valorEnt;
              terfin.tipo = tipo_variable.ENTERO;
              term1.valorEnt = terfin.valorEnt;
              terfin.constante = true;
            }
            else if (term1.constante && !estado) //term2 valor desconocido
            {
              terfin.tipo = tipo_variable.ENTERO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.add("STC " + term1.valorEnt);
              auxilar.addAll(term2.listado);
              auxilar.add("SBT");
              terfin.listado = auxilar;
              term1.listado = auxilar;
              term1.constante = false;
            }
            else if (term2.constante && !estado) //term1 valor desconocido
            {
              terfin.tipo = tipo_variable.ENTERO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              auxilar.add("STC " + term2.valorEnt);
              auxilar.add("SBT");
              terfin.listado = auxilar;
              term1.listado = auxilar;
            }
            else //term1 y term 2 valor desconocido
            {
              terfin.tipo = tipo_variable.ENTERO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              auxilar.addAll(term2.listado);
              auxilar.add("SBT");
              terfin.listado = auxilar;
              term1.listado = auxilar;
            }
          }
          else if (tk.image.equals("or") || tk.image.equals("OR"))
          {
            if (term1.tipo != tipo_variable.BOOLEANO)
            {
              errorSemantico("Error en operador aditivo, se esperaba BOOLEANO [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
            }
            else if (term1.constante && term2.constante && !estado) //BOOLEANO 'or' BOOLEANO
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.valorBool = term1.valorBool
            | term2.valorBool;
              term1.valorBool = terfin.valorBool;
              terfin.constante = true;
            }
            else if (term1.constante && !estado) //term2 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              if (term1.valorBool)
              {
                auxilar.add("STC 1");
              }
              else
              {
                auxilar.add("STC 0");
              }
              auxilar.addAll(term2.listado);
              auxilar.add("OR");
              terfin.listado = auxilar;
              term1.constante = false;
              term1.listado = auxilar;
            }
            else if (term2.constante && !estado) //term1 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              if (term2.valorBool)
              {
                auxilar.add("STC 1");
              }
              else
              {
                auxilar.add("STC 0");
              }
              auxilar.add("OR");
              terfin.listado = auxilar;
              term1.listado = auxilar;
            }
            else //term1 y term 2 valor desconocido
            {
              terfin.tipo = tipo_variable.BOOLEANO;
              terfin.constante = false;
              ArrayList < String > auxilar = new ArrayList < String > ();
              auxilar.addAll(term1.listado);
              auxilar.addAll(term2.listado);
              auxilar.add("OR");
              terfin.listado = auxilar;
              term1.listado = auxilar;
            }
          }
          else
          {
            errorSemantico("Error Supremo(101), Codigo Incorrecto [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
          }
        }
        else if ((term1.tipo == tipo_variable.DESCONOCIDO) && (term2.tipo == tipo_variable.DESCONOCIDO))
        { //LOS 2 DESCONOCIDOS  PETADO NO HACE FALTA GENEAR CODIGO
          terfin.tipo = tipo_variable.DESCONOCIDO;
          terfin.constante = false;
        }
        else
        {
          errorSemantico("Error Supremo(102), Codigo Incorrecto [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
        }
    }
      {if (true) return terfin;}
    throw new Error("Missing return statement in function");
  }

  static final public Token operador_multiplicativo() throws ParseException {
  Token tk = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIV:
      tk = jj_consume_token(DIV);
      break;
    case MUL:
      tk = jj_consume_token(MUL);
      break;
    case tAND:
      tk = jj_consume_token(tAND);
      break;
    case tMOD:
      tk = jj_consume_token(tMOD);
      break;
    case tDIV:
      tk = jj_consume_token(tDIV);
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return tk;}
    throw new Error("Missing return statement in function");
  }

  static final public Token operador_aditivo() throws ParseException {
  Token tk = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MAS:
      tk = jj_consume_token(MAS);
      break;
    case MENOS:
      tk = jj_consume_token(MENOS);
      break;
    case tOR:
      tk = jj_consume_token(tOR);
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return tk;}
    throw new Error("Missing return statement in function");
  }

  static final public Token operador_relacional() throws ParseException {
  Token tk = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tMAYOR:
      tk = jj_consume_token(tMAYOR);
      break;
    case tMENOR:
      tk = jj_consume_token(tMENOR);
      break;
    case tIGUAL:
      tk = jj_consume_token(tIGUAL);
      break;
    case tMAI:
      tk = jj_consume_token(tMAI);
      break;
    case tMEI:
      tk = jj_consume_token(tMEI);
      break;
    case tNI:
      tk = jj_consume_token(tNI);
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return tk;}
    throw new Error("Missing return statement in function");
  }

/*factor::= 	 <tNOT> factor| 	 "-” factor|    "(" expresion ")" |    <tENTACAR> "(" expresion ")" |    <tCARAENT> "(" expresion ")" |    <tCONSTENTERA> |    <tCONSTCHAR> |    <tCONSTCAD> |    <tTRUE> |    <tFALSE> |    <tIDENTIFICADOR> */
  static final public RegistroFactor factor(boolean estado) throws ParseException {
  Token tk = null;
  RegistroFactor tpFactor = new RegistroFactor();
  RegistroFactor tpAuxi = new RegistroFactor();
  ArrayList < String > auxilar = new ArrayList < String > ();
  Simbolo s1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tNOT:
      tk = jj_consume_token(tNOT);
      tpFactor = factor(estado);
      if (tpFactor.tipo != tipo_variable.BOOLEANO && tpFactor.tipo != tipo_variable.DESCONOCIDO)
      {
        errorSemantico("Tipo incompatible. Se esperaba booleano [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
        tpFactor.tipo = tipo_variable.BOOLEANO;
        tpFactor.constante = false;
      }
      else if (tpFactor.tipo == tipo_variable.BOOLEANO && tpFactor.constante && !estado)
      {
        tpFactor.constante = true;
        tpFactor.valorBool = !tpFactor.valorBool;
        tpFactor.tipo = tipo_variable.BOOLEANO;
      }
      else if (tpFactor.tipo == tipo_variable.DESCONOCIDO || tpFactor.tipo == tipo_variable.BOOLEANO)
      {
        tpFactor.constante = false;
        tpFactor.tipo = tipo_variable.BOOLEANO;
        tpFactor.listado.add("NGB");
      }
      else
      {
        errorSemantico("Error Supremo(103), Codigo Incorrecto [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
      }
      {if (true) return tpFactor;}
      break;
    case 51:
      jj_consume_token(51);
      tpFactor = expresion(estado);
      jj_consume_token(52);
      {if (true) return tpFactor;}
      break;
    case tENTACAR:
      tk = jj_consume_token(tENTACAR);
      jj_consume_token(51);
      tpAuxi = expresion(estado);
      jj_consume_token(52);
      if ((tpAuxi.tipo != tipo_variable.ENTERO) && (tpAuxi.tipo != tipo_variable.DESCONOCIDO))
      {
        errorSemantico("Tipo incompatible. Se esperaba entero [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
        tpFactor.tipo = tipo_variable.CARACTER;
        tpFactor.constante = false;
      }
      else if (tpAuxi.tipo == tipo_variable.ENTERO && tpAuxi.constante)
      {
         tpFactor.constante = true;
        tpFactor.tipo = tipo_variable.CARACTER;
        tpFactor.valorChar = (char) tpAuxi.valorEnt;
         tpFactor.variable = tpAuxi.variable;
         tpFactor.listado = tpAuxi.listado;
      }
      else if (tpAuxi.tipo == tipo_variable.DESCONOCIDO || tpAuxi.tipo == tipo_variable.ENTERO)
      {
        tpFactor.tipo = tipo_variable.CARACTER;
        tpFactor.variable = tpAuxi.variable;
        tpFactor.listado = tpAuxi.listado;
      }
      else
      {
        errorSemantico("Error Supremo(104), Codigo Incorrecto [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
      }
      {if (true) return tpFactor;}
      break;
    case tCARAENT:
      tk = jj_consume_token(tCARAENT);
      jj_consume_token(51);
      tpAuxi = expresion(estado);
      jj_consume_token(52);
      if (tpAuxi.tipo != tipo_variable.CARACTER && tpAuxi.tipo != tipo_variable.DESCONOCIDO)
      {
        errorSemantico("Tipo incompatible. Se esperaba caracter [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
        tpFactor.tipo = tipo_variable.ENTERO;
        tpFactor.constante = false;
      }
      else if (tpAuxi.tipo == tipo_variable.CARACTER && tpAuxi.constante)
      {
          tpFactor.constante = true;
        tpFactor.tipo = tipo_variable.ENTERO;
        tpFactor.valorEnt = (int) tpAuxi.valorChar;
        tpFactor.variable = tpAuxi.variable;
        tpFactor.listado = tpAuxi.listado;
      }
      else if (tpAuxi.tipo == tipo_variable.DESCONOCIDO || tpAuxi.tipo == tipo_variable.CARACTER)
      {
        tpFactor.tipo = tipo_variable.ENTERO;
       tpFactor.variable = tpAuxi.variable;
       tpFactor.listado = tpAuxi.listado;
      }
      else
      {
        errorSemantico("Error Supremo(105), Codigo Incorrecto [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
      }
      {if (true) return tpFactor;}
      break;
    case tIDENTIFICADOR:
      tk = jj_consume_token(tIDENTIFICADOR);
      s1 = tablaSim.buscar_simbolo(tk.image);
      if (s1 == null)
      {
        errorSemantico("Identificador Desconocido [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");
        tpFactor.tipo = tipo_variable.DESCONOCIDO;
        tpFactor.constante = false;
      }
      else
      {
        tpFactor = s1.getFactor();
        if (tpFactor == null)
        {
          tpFactor = new RegistroFactor();
          tpFactor.tipo = s1.getVariable();
        }
        tpFactor.variable = true;
        tpFactor.par = s1.getParametro();
        if (!tpFactor.constante || estado) //Si no sabemos el valor en compilacion
        {
          auxilar.add("SRF " + (nivel - s1.getNivel()) + " " + s1.getDir());
          auxilar.add("DRF");
          tpFactor.listado = auxilar;
        }
      }
      {if (true) return tpFactor;}
      break;
    case tCONSTENTERA:
      tk = jj_consume_token(tCONSTENTERA);
      if (estado)
      {
        tpFactor.constante = false;
        auxilar.add("STC " + Integer.parseInt(tk.image));
        tpFactor.listado = auxilar;
      }
      else
      {
        /*Propagar la informacion de la variable */
        tpFactor.valorEnt = Integer.parseInt(tk.image);
        tpFactor.constante = true;
      }
      tpFactor.tipo = tipo_variable.ENTERO;
      {if (true) return tpFactor;}
      break;
    case tCONSTCHAR:
      tk = jj_consume_token(tCONSTCHAR);
      if (estado)
      {
        tpFactor.constante = false;
        auxilar.add("STC " + (int) tk.image.charAt(1));
        tpFactor.listado = auxilar;
      }
      else
      {
        /*Propagar la informacion de la variable */
        tpFactor.valorChar = (tk.image).charAt(1);
        tpFactor.constante = true;
      }
      tpFactor.tipo = tipo_variable.CARACTER;
      {if (true) return tpFactor;}
      break;
    case tCONSTCAD:
      tk = jj_consume_token(tCONSTCAD);
      /*Propagar la informacion de la variable */
      tpFactor.tipo = tipo_variable.CADENA;
      tpFactor.valorCadena = (tk.image);
      tpFactor.constante = true;
      {if (true) return tpFactor;}
      break;
    case tTRUE:
      tk = jj_consume_token(tTRUE);
      if (estado)
      {
        tpFactor.constante = false;
        auxilar.add("STC 1");
        tpFactor.listado = auxilar;
      }
      else
      {
        /*Propagar la informacion de la variable */
        tpFactor.valorBool = true;
        tpFactor.constante = true;
      }
      tpFactor.tipo = tipo_variable.BOOLEANO;
      {if (true) return tpFactor;}
      break;
    case tFALSE:
      tk = jj_consume_token(tFALSE);
      if (estado) //Si es un while
      {
        tpFactor.constante = false;
        auxilar.add("STC 0");
        tpFactor.listado = auxilar;
      }
      else
      {
        /*Propagar la informacion de la variable */
        tpFactor.valorBool = false;
        tpFactor.constante = true;
      }
      tpFactor.tipo = tipo_variable.BOOLEANO;
      {if (true) return tpFactor;}
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public AnalsisLexicoTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[25];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x400,0x70000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3440000,0x3440000,0x70000000,0x0,0x0,0x0,0x100000,0x80008000,0x0,0x0,0xc002300,0x40c0,0xc002300,0x40c0,0x0,0x80008000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x8,0x40000,0x20000,0x30,0x80000,0x30,0x40000,0x10000,0x10000,0x0,0x40000,0x81000,0x81000,0x0,0x9e007,0x40000,0xfc0,0x0,0x0,0x0,0x0,0xfc0,0x9e007,};
   }

  /** Constructor with InputStream. */
  public AnalsisLexico(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public AnalsisLexico(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new AnalsisLexicoTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public AnalsisLexico(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new AnalsisLexicoTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public AnalsisLexico(AnalsisLexicoTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(AnalsisLexicoTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[53];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 25; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 53; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
