/** * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+ */options{  static = true;  IGNORE_CASE = true;}PARSER_BEGIN(AnalsisLexico)package Practica2;import java.io.*;import Practica2.Simbolo.tipo_variable;import Practica2.Simbolo.clase_parametro;import Practica2.Simbolo.tipo_simbolo;import java.util.ArrayList;public class AnalsisLexico{  static Tabla_simbolos tablaSim = new Tabla_simbolos();  static int nivel;  static int dir = 3;  static int peso = 0;  static int etiqueta = - 1;  static final int INICIAL = 3; /* 3- Encabezamiento  estatico, encabezamiento dinamico, direccion de retorno */  public static void main(String args []) throws ParseException  {    AnalsisLexico parser = null;    if (args.length == 0)    {      System.out.println("Uso: java AnalisisLexico fichero.c");      System.exit(0);    }    try    {      parser = new AnalsisLexico(new FileInputStream(args [0]));      tablaSim.inicializar_tabla();      nivel = 0;      parser.entrada();      System.out.println("Analisis terminado");      System.out.println("No se han encontrado errores");    }    catch (Exception e)    {      System.out.println("NOK.");      System.out.println(e.getMessage());      e.printStackTrace();      AnalsisLexico.ReInit(System.in);    }    catch (Error e)    {      SimpleCharStream stream = parser.jj_input_stream;      System.out.println("ERROR LEXICO (" + stream.getBeginLine() + "," + stream.getBeginColumn() + ") :simbolo no reconocido: " + stream.GetImage());    }  }  void skipToSaltoLinea()  {    Token tok;    while (true)    {      tok = getToken(1);      if (tok.image.equals("\n"))      {        break;      }      tok = getNextToken();    }  }  static void errorSemantico(String text)  {    System.out.println(text);  }  /** * Metodo auxiliar para  centralizar la escritura de codigo **/  public static void generarCodigo(String text)  {    System.out.println(text);  }  public static void generarCodigo(ArrayList < String > text)  {    for (int i = 0; i < text.size(); i++)    {      System.out.println(text.get(i));    }  }  /** * Metodo auxiliar que devuelve el tamaño de tipo_variable **/  public static int tamanio(tipo_variable tipo)  {    if (tipo == tipo_variable.ENTERO)    {      return 2;    }    else if (tipo == tipo_variable.BOOLEANO)    {      return 1;    }    else if (tipo == tipo_variable.CARACTER)    {      return 1;    }    else    {      return 2;    }  }  /** * Inicializa la escritura en fichero externo **/  public static void inicializar_generacion_codigo()  {}  /** * Genera una nueva etiqueta */  public static String nueva_etiqueta()  {    etiqueta++;    return "L" + etiqueta + ":";  }}PARSER_END(AnalsisLexico)SKIP : //comentarios{  < tCOMENTARIO : "%" (~[ "\n" ])* >}SKIP : //espacios tabulaciones ...{  " "| "\t"| "\n"| "\r"}TOKEN : //Operadores Aritmeticos{  < MAS : "+" >| < MENOS : "-" >| < DIV : "/" >| < MUL : "*" >}TOKEN : //palabras reservadas{  < tPROGRAMA : "programa" >| < tFINPROGRAMA : "finprograma" >| < tVAR : "var" >| < tAND : "and" >| < tOR : "or" >| < tNOT : "not" >| < tPRINCIPIO : "principio" >| < tFIN : "fin" >| < tSI : "si" >| < tENT : "ent" >| < tSI_NO : "si_no" >| < tFSI : "fsi" >| < tMQ : "mq" >| < tFMQ : "fmq" >| < tESCRIBIR : "escribir" >| < tLEER : "leer" >| < tMOD : "mod" >| < tDIV : "div" >| < tENTERO : "entero" >| < tBOOLEANO : "booleano" >| < tCARACTER : "caracter" >| < tTRUE : "true" >| < tFALSE : "false" >| < tENTACAR : "entacar" >| < tCARAENT : "caraent" >| < tACCION : "accion" >| < tVAL : "val" >| < tREF : "ref" >| < tMAYOR : ">" >| < tMENOR : "<" >| < tIGUAL : "=" >| < tMAI : ">=" >| < tMEI : "<=" >| < tNI : "<>" >| < tOPAS : ":=" >}TOKEN : //cosas{  < tCONSTENTERA : ([ "0"-"9" ])+ >| < tCONSTCHAR : "\"" ~[ "\"" ] "\"" >| < tCONSTCAD : "\"" ~[ "\"" ] (~[ "\"" ])+ "\"" >| < tIDENTIFICADOR :    [ "a"-"z" ]    (      [ "a"-"z" ]    | [ "0"-"9" ]    | [ "_" ]    )*    (      [ "0"-"9" ]    | [ "a"-"z" ]    )* > //Faltan mayusculas}Token entrada() :{  Token tk;  String etiq;  ArrayList < String > cacciones, cbloqueinstr;}{  (    < tPROGRAMA >    {      etiq = nueva_etiqueta();      generarCodigo("ENP " + etiq);    }    tk = < tIDENTIFICADOR > ";" declaracion_variables() declaracion_acciones()    {      generarCodigo(etiq);    }    bloque_sentencias()    {      /*      generarCodigo(cacciones);      generarCodigo("; Comienzo de " + tk.image);      generarCodigo(etiq + ":");      generarCodigo(cbloqueinstr);      generarCodigo("; Fin de " + tk.image);         */      generarCodigo("LVP");    }    < tFINPROGRAMA >    {      return tk;    }  )*  < EOF >}Token declaracion_variables() :{  Token tk = null;}{  (    declaracion() ";"  )*  {    return tk;  }}ArrayList < String > declaracion_acciones() :{  ArrayList < String > tk = null;}{  (    declaracion_accion()  )*  {    return tk;  }}Token declaracion_accion() :{  Token tk = null;  String etiq;}{  (    cabecera_accion() ";" declaracion_variables() declaracion_acciones()    {      etiq = nueva_etiqueta();      generarCodigo(etiq);    }    bloque_sentencias()  )  {    tablaSim.eliminarNivel(nivel);    nivel--;    generarCodigo("CSF");    return tk;  }}/*	declaracion ::= tipo_variables  identificadores*/void declaracion() :{  tipo_variable tipoVar;}{  (    tipoVar = tipo_variables() identificadores(tipoVar)  )}/*    identificadores ::= <identificador> (“,” <identificador>)* */void identificadores(tipo_variable tipo) :{  Token t1, t2 = null;}{  (    t1 = < tIDENTIFICADOR >    {      if (tablaSim.introducir_variable(t1.image, tipo, nivel, dir) == null)      {        errorSemantico("Variable duplicada [" + t1.beginLine + "," + t1.beginColumn + "] " + "Token: <" + t1.image + ">");      }      else      {        dir = dir + 1;        peso = peso + tamanio(tipo);      }    }    (      "," t2 = < tIDENTIFICADOR >      {        if (tablaSim.introducir_variable(t2.image, tipo, nivel, dir) == null)        {          errorSemantico("Variable duplicada [" + t2.beginLine + "," + t2.beginColumn + "] " + "Token: <" + t2.image + ">");        }        else        {          dir = dir + 1;          peso = peso + tamanio(tipo);        }      }    )*  )}ArrayList < String > bloque_sentencias() :{  ArrayList < String > tk = null;}{  (    < tPRINCIPIO > lista_sentencias(false) < tFIN >  )  {    return tk;  }}Token cabecera_accion() :{  Token tk = null;  Simbolo s = null;  boolean ok = false;  ArrayList < Simbolo > listadoparametros;}{  (    < tACCION > tk = < tIDENTIFICADOR >    {      s = tablaSim.buscar_simbolo(tk.image);      if (s == null || s.getNivel() != nivel)      {        s = tablaSim.introducir_accion(tk.image, nivel, etiqueta + 1);        ok = true;      }      else      {        errorSemantico("Accion duplicada [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");      }      nivel++;      dir = INICIAL;      peso = 0;    }    listadoparametros = parametros_formales()    {      if (s != null)      {        s.setListaParametros(listadoparametros);      }    }  )  {    return tk;  }}ArrayList < Simbolo > parametros_formales() :{  ArrayList < Simbolo > listaformal = new ArrayList < Simbolo > ();  ArrayList < Simbolo > listaAuxiliar1;  ArrayList < Simbolo > listaAuxiliar2;}{  (    (      "("      (        listaAuxiliar1 = parametros()        {          listaformal.addAll(listaAuxiliar1);        }        (          ";" listaAuxiliar2 = parametros()          {            listaformal.addAll(listaAuxiliar2);          }        )*      )?      ")"    )?  )  {    return listaformal;  }}ArrayList < Simbolo > parametros() :{  clase_parametro tkclase = null;  tipo_variable tktipo = null;  ArrayList < Simbolo > listaglobal;}{  (    tkclase = clase_parametros() tktipo = tipo_variables() listaglobal = lista_parametros(tktipo, tkclase)  )  {    return listaglobal;  }}clase_parametro clase_parametros() :{}{  (    < tVAL >    {      return clase_parametro.VAL;    }  | < tREF >    {      return clase_parametro.REF;    }  )}ArrayList < Simbolo > lista_parametros(tipo_variable tipo, clase_parametro clase) :{  Token t1, t2 = null;  Simbolo s1, s2;  ArrayList < Simbolo > lista = new ArrayList < Simbolo > ();}{  (    t1 = < tIDENTIFICADOR >    {      s1 = tablaSim.introducir_parametro(t1.image, tipo, clase, nivel, dir);      lista.add(s1);      if (s1 == null)      {        errorSemantico("Identificador duplicado [" + t1.beginLine + "," + t1.beginColumn + "] " + "Token: <" + t1.image + ">");      }      else      {        dir = dir + tamanio(tipo);      }    }    (      "," t2 = < tIDENTIFICADOR >      {        s2 = tablaSim.introducir_parametro(t2.image, tipo, clase, nivel, dir);        lista.add(s2);        if (s2 == null)        {          errorSemantico("Identificador duplicado [" + t2.beginLine + "," + t2.beginColumn + "] " + "Token: <" + t2.image + ">");        }        else        {          dir = dir + tamanio(tipo);        }      }    )*  )  {    return lista;  }}Token lista_sentencias(boolean estado) :{  Token tk = null;}{  (    sentencia(estado)  )+  {    return tk;  }}Token sentencia(boolean estado) :{  Token tk = null;}{  (    leer() ";"  | escribir(estado) ";"  | asignacion(estado)  | seleccion(estado)  | mientras_que()  )  {    return tk;  }}tipo_variable tipo_variables() :{}{  (    < tENTERO >    {      return tipo_variable.ENTERO;    }  | < tCARACTER >    {      return tipo_variable.CARACTER;    }  | < tBOOLEANO >    {      return tipo_variable.BOOLEANO;    }  )}/*leer::=  <tLEER> "(" <tIDENTIFICADOR> ( "," < tIDENTIFICADOR >  )* ")"*/void leer() :{  Token t1, t2 = null;  Simbolo s1, s2;}{  (    < tLEER > "("    (      t1 = < tIDENTIFICADOR >      {        s1 = tablaSim.buscar_simbolo(t1.image);        if (s1 == null)        {          errorSemantico("No existe variable [" + t1.beginLine + "," + t1.beginColumn + "] " + "Token: <" + t1.image + ">");        }        else if ((s1.getTipo() == tipo_simbolo.PARAMETRO) && (s1.getParametro() == clase_parametro.VAL))        {          errorSemantico("Leer tiene que recibir un parametro por referencia [" + t1.beginLine + "," + t1.beginColumn + "] " + "Token: <" + t1.image + ">");        }        else        {          RegistroFactor auxi = s1.getFactor();          if (auxi != null)          {            auxi.constante = false;            s1.setFactor(auxi);          }          generarCodigo("SRF " + (nivel - s1.getNivel()) + " " + s1.getDir());          if (s1.getVariable() == tipo_variable.ENTERO)          {            generarCodigo("RD 1");          }          else          {            generarCodigo("RD 0");          }        }      }      (        "," t2 = < tIDENTIFICADOR >        {          s2 = tablaSim.buscar_simbolo(t2.image);          if (s2 == null)          {            errorSemantico("No existe variable [" + t2.beginLine + "," + t2.beginColumn + "] " + "Token: <" + t2.image + ">");          }          else if ((s2.getTipo() == tipo_simbolo.PARAMETRO) && (s2.getParametro() == clase_parametro.VAL))          {            errorSemantico("Leer tiene que recibir un parametro por referencia [" + t2.beginLine + "," + t2.beginColumn + "] " + "Token: <" + t2.image + ">");          }          else          {            RegistroFactor auxi = s2.getFactor();            if (auxi != null)            {              auxi.constante = false;              s1.setFactor(auxi);            }            generarCodigo("SRF " + (nivel - s2.getNivel()) + " " + s2.getDir());            if (s2.getVariable() == tipo_variable.ENTERO)            {              generarCodigo("RD 1");            }            else            {              generarCodigo("RD 0");            }          }        }      )*    )    ")"  )}Token escribir(boolean estado) :{  Token tk = null;}{  (    tk = < tESCRIBIR > "(" lista_escribibles(tk,estado) ")"  )  {    return tk;  }}/*	asignacion ::= < tIDENTIFICADOR > ( < tOPAS > expresion | argumentos )? ";"*/void asignacion(boolean estado) :{  Token tk = null;  Simbolo s1;  boolean esAccion = true;  RegistroFactor expre;  ArrayList < RegistroFactor > lista = null;}{  (    tk = < tIDENTIFICADOR >    (      < tOPAS > expre = expresion(estado)      {        esAccion = false;        s1 = tablaSim.buscar_simbolo(tk.image);        if (s1 == null)        {          errorSemantico("No existe variable [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");        }        else if ((s1.getTipo() == tipo_simbolo.PARAMETRO) && (s1.getParametro() == clase_parametro.VAL))        {          errorSemantico("Parametro por valor en la parte izquierda de la asignacion [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");        }        else if (expre.constante)        {          // SRF 0 s1.getDir()          generarCodigo("SRF " + (nivel - s1.getNivel()) + " " + s1.getDir());          if (estado)          {            expre.constante = false;            s1.setFactor(expre);          }          else s1.setFactor(expre);          if (expre.tipo == tipo_variable.ENTERO)          { //STC expre.valorEnt;            generarCodigo("STC " + expre.valorEnt);          }          else if (expre.tipo == tipo_variable.BOOLEANO)          { //STC expre.valorBool;            if (expre.valorBool)            {              generarCodigo("STC 1");            }            else            {              generarCodigo("STC 0");            }          }          else if (expre.tipo == tipo_variable.CARACTER)          { //STC expre.valorChar;            generarCodigo("STC " + (int) expre.valorChar);          }          //ASG          generarCodigo("ASG");        }        else        {          s1.setFactor(expre);          // SRF 0 s1.getDir()          generarCodigo("SRF " + (nivel - s1.getNivel()) + " " + s1.getDir());          //expre.listado          generarCodigo(expre.listado);          //ASG          generarCodigo("ASG");        }      }    | lista = argumentos()    )?    {      if (esAccion)      {        s1 = tablaSim.buscar_simbolo(tk.image);        if ((s1 == null) || (s1.getTipo() != tipo_simbolo.ACCION))        {          errorSemantico("No existe accion [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");        }        else if (s1.getListaParametros().size() != 0)        {          if ((lista == null) && (s1.getListaParametros().size() > 0))          {            errorSemantico("Se esperaban mas parametros [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");          }          else if (lista.size() != s1.getListaParametros().size())          {            errorSemantico("Numero de parametros incorrecto [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");          }          else          {            for (int i = 0; i < lista.size(); i++)            {              if (lista.get(i).tipo != s1.getListaParametros().get(i).getVariable())              {                errorSemantico("Parametro incorrecto se esperaba " + lista.get(i).tipo + "[" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");              }              else if ((!lista.get(i).variable && s1.getListaParametros().get(i).getParametro() == clase_parametro.REF) || ((lista.get(i).par == clase_parametro.VAL) && (s1.getListaParametros().get(i).getParametro() == clase_parametro.REF)))              {                errorSemantico("Un parametro recibido por valor no se puede pasar por referencias " + lista.get(i).tipo + "[" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");              }              else if (lista.get(i).constante && !lista.get(i).variable)              {                expre = lista.get(i);                if (expre.tipo == tipo_variable.ENTERO)                { //STC expre.valorEnt;                  generarCodigo("STC " + expre.valorEnt);                }                else if (expre.tipo == tipo_variable.BOOLEANO)                { //STC expre.valorBool;                  if (expre.valorBool)                  {                    generarCodigo("STC 1");                  }                  else                  {                    generarCodigo("STC 0");                  }                }                else if (expre.tipo == tipo_variable.CARACTER)                { //STC expre.valorChar;                  generarCodigo("STC " + (int) expre.valorChar);                }              }              else if (lista.get(i).variable && lista.get(i).par == clase_parametro.REF)              {                generarCodigo(lista.get(i).listado.get(0));              }              else              {                generarCodigo(lista.get(i).listado);              }            }          }        }        //OSF nivel l a         generarCodigo("OSF " + peso + " " + nivel + " L" + s1.getDir() + ":");      }    }    ";"  )}Token mientras_que() :{  RegistroFactor term = null;  Token tk = null;  String etqMQ, etqFIN;}{  (    tk = < tMQ >    {      etqMQ = nueva_etiqueta();      generarCodigo(etqMQ);    }    term = expresion(true)    {      {        if ((term.tipo != tipo_variable.DESCONOCIDO) && (term.tipo != tipo_variable.BOOLEANO))        {          errorSemantico("La condición en el mientras_que debe ser un booleano [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");        }      }      if (term.constante)      { //warning o error        errorSemantico("ERRORR");      }      else      {        generarCodigo(term.listado);      }      etqFIN = nueva_etiqueta();      generarCodigo("JMF " + etqFIN);    }    lista_sentencias(true) < tFMQ >    {      generarCodigo("JMP " + etqMQ);      generarCodigo(etqFIN);    }  )  {    return tk;  }}Token seleccion(boolean estado) :{  RegistroFactor term = null;  Token tk = null;  String etqSINO, etqFIN;  boolean sino = false;}{  (    tk = < tSI > term = expresion(estado)    {      if ((term.tipo != tipo_variable.DESCONOCIDO) && (term.tipo != tipo_variable.BOOLEANO))      {        errorSemantico("La condición en el si debe ser un booleano [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");      }      if (term.constante)      { //warning o error        errorSemantico("ERRORR");      }      else      {        generarCodigo(term.listado);      }      etqSINO = nueva_etiqueta();      generarCodigo("JMF " + etqSINO);    }    < tENT > lista_sentencias(true)    (      < tSI_NO >      {        sino = true;        etqFIN = nueva_etiqueta();        generarCodigo("JMP " + etqFIN);        generarCodigo(etqSINO);      }      lista_sentencias(true)      {        generarCodigo(etqFIN);      }    )?    {      if (!sino)      {        generarCodigo(etqSINO);      }    }    < tFSI >  )  {    return tk;  }}ArrayList < RegistroFactor > argumentos() :{  ArrayList < RegistroFactor > lista = null;}{  (    "("    (      lista = lista_expresiones(false)    )?    ")"  )  {    return lista;  }}ArrayList < RegistroFactor > lista_expresiones(boolean estado) :{  ArrayList < RegistroFactor > lista = new ArrayList < RegistroFactor > ();  RegistroFactor term1, term2 = null;}{  (    term1 = expresion(estado)    {      lista.add(term1);    }    (      "," term2 = expresion(estado)      {        {          lista.add(term2);        }      }    )*  )  {    return lista;  }}/* expresion::= expresion_simple ( operador_relacional expresion_simple )?*/RegistroFactor expresion(boolean estado) : //TERMINAR{  RegistroFactor term1, term2 = null;  RegistroFactor terfin = null;  Token tk = null;}{  (    term1 = expresion_simple(estado)    {      terfin = term1;    }    (      tk = operador_relacional() term2 = expresion_simple(estado)      {        terfin = new RegistroFactor();        if ((term1.tipo != tipo_variable.DESCONOCIDO) && (term2.tipo != tipo_variable.DESCONOCIDO) && (term1.tipo != term2.tipo))        {          errorSemantico("Los operandos deben ser del mismo tipo [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");          terfin.tipo = tipo_variable.DESCONOCIDO;          terfin.constante = false;        }        else if ((term1.tipo != tipo_variable.DESCONOCIDO) && (term2.tipo != tipo_variable.DESCONOCIDO) && (term1.tipo == term2.tipo)) //AMBOS OPERANDOS DEL MISMO TIPO         {          if (tk.image.equals(">"))          {            if (term1.tipo != tipo_variable.ENTERO && term1.tipo != tipo_variable.CARACTER)            {              errorSemantico("Error en operador relacional, se esperaba ENTERO O CARACTER[" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;            }            else if (term1.constante && term2.constante && !estado)            {              terfin.constante = true;              terfin.tipo = tipo_variable.BOOLEANO;              if (term1.tipo == tipo_variable.ENTERO)              {                terfin.valorBool = term1.valorEnt > term2.valorEnt;              }              else              {                terfin.valorBool = term1.valorChar > term2.valorChar;              }            }            else if (term1.constante && !estado) //term2 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              if (term1.tipo == tipo_variable.ENTERO)              {                auxilar.add("STC " + term1.valorEnt);              }              else              {                auxilar.add("STC " + (int) term1.valorChar);              }              auxilar.addAll(term2.listado);              auxilar.add("GT");              terfin.listado = auxilar;            }            else if (term2.constante && !estado) //term1 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              if (term1.tipo == tipo_variable.ENTERO)              {                auxilar.add("STC " + term2.valorEnt);              }              else              {                auxilar.add("STC " + (int) term2.valorChar);              }              auxilar.add("GT");              terfin.listado = auxilar;            }            else //term1 y term 2 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              auxilar.addAll(term2.listado);              auxilar.add("GT");              terfin.listado = auxilar;            }          }          else if (tk.image.equals("<"))          {            if (term1.tipo != tipo_variable.ENTERO && term1.tipo != tipo_variable.CARACTER)            {              errorSemantico("Error en operador relacional, se esperaba ENTERO O CARACTER[" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;            }            else if (term1.constante && term2.constante && !estado)            {              terfin.constante = true;              terfin.tipo = tipo_variable.BOOLEANO;              if (term1.tipo == tipo_variable.ENTERO)              {                terfin.valorBool = term1.valorEnt < term2.valorEnt;              }              else              {                terfin.valorBool = term1.valorChar < term2.valorChar;              }            }            else if (term1.constante && !estado) //term2 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              if (term1.tipo == tipo_variable.ENTERO)              {                auxilar.add("STC " + term1.valorEnt);              }              else              {                auxilar.add("STC " + (int) term1.valorChar);              }              auxilar.addAll(term2.listado);              auxilar.add("LT");              terfin.listado = auxilar;            }            else if (term2.constante && !estado) //term1 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              if (term1.tipo == tipo_variable.ENTERO)              {                auxilar.add("STC " + term2.valorEnt);              }              else              {                auxilar.add("STC " + (int) term2.valorChar);              }              auxilar.add("LT");              terfin.listado = auxilar;            }            else //term1 y term 2 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              auxilar.addAll(term2.listado);              auxilar.add("LT");              terfin.listado = auxilar;            }          }          else if (tk.image.equals("="))          {            if (term1.tipo != tipo_variable.ENTERO && term1.tipo != tipo_variable.CARACTER)            {              errorSemantico("Error en operador relacional, se esperaba ENTERO O CARACTER[" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;            }            else if (term1.constante && term2.constante && !estado)            {              terfin.constante = true;              terfin.tipo = tipo_variable.BOOLEANO;              if (term1.tipo == tipo_variable.ENTERO)              {                terfin.valorBool = term1.valorEnt == term2.valorEnt;              }              else              {                terfin.valorBool = term1.valorChar == term2.valorChar;              }            }            else if (term1.constante && !estado) //term2 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              if (term1.tipo == tipo_variable.ENTERO)              {                auxilar.add("STC " + term1.valorEnt);              }              else              {                auxilar.add("STC " + (int) term1.valorChar);              }              auxilar.addAll(term2.listado);              auxilar.add("EQ");              terfin.listado = auxilar;            }            else if (term2.constante && !estado) //term1 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              if (term1.tipo == tipo_variable.ENTERO)              {                auxilar.add("STC " + term2.valorEnt);              }              else              {                auxilar.add("STC " + (int) term2.valorChar);              }              auxilar.add("EQ");              terfin.listado = auxilar;            }            else //term1 y term 2 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              auxilar.addAll(term2.listado);              auxilar.add("EQ");              terfin.listado = auxilar;            }          }          else if (tk.image.equals("<="))          {            if (term1.tipo != tipo_variable.ENTERO && term1.tipo != tipo_variable.CARACTER)            {              errorSemantico("Error en operador relacional, se esperaba ENTERO O CARACTER[" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;            }            else if (term1.constante && term2.constante && !estado)            {              terfin.constante = true;              terfin.tipo = tipo_variable.BOOLEANO;              if (term1.tipo == tipo_variable.ENTERO)              {                terfin.valorBool = term1.valorEnt <= term2.valorEnt;              }              else              {                terfin.valorBool = term1.valorChar <= term2.valorChar;              }            }            else if (term1.constante && !estado) //term2 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              if (term1.tipo == tipo_variable.ENTERO)              {                auxilar.add("STC " + term1.valorEnt);              }              else              {                auxilar.add("STC " + (int) term1.valorChar);              }              auxilar.addAll(term2.listado);              auxilar.add("LTE");              terfin.listado = auxilar;            }            else if (term2.constante && !estado) //term1 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              if (term1.tipo == tipo_variable.ENTERO)              {                auxilar.add("STC " + term2.valorEnt);              }              else              {                auxilar.add("STC " + (int) term2.valorChar);              }              auxilar.add("LTE");              terfin.listado = auxilar;            }            else //term1 y term 2 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              auxilar.addAll(term2.listado);              auxilar.add("LTE");              terfin.listado = auxilar;            }          }          else if (tk.image.equals(">="))          {            if (term1.tipo != tipo_variable.ENTERO && term1.tipo != tipo_variable.CARACTER)            {              errorSemantico("Error en operador relacional, se esperaba ENTERO O CARACTER[" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;            }            else if (term1.constante && term2.constante && !estado)            {              terfin.constante = true;              terfin.tipo = tipo_variable.BOOLEANO;              if (term1.tipo == tipo_variable.ENTERO)              {                terfin.valorBool = term1.valorEnt >= term2.valorEnt;              }              else              {                terfin.valorBool = term1.valorChar >= term2.valorChar;              }            }            else if (term1.constante && !estado) //term2 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              if (term1.tipo == tipo_variable.ENTERO)              {                auxilar.add("STC " + term1.valorEnt);              }              else              {                auxilar.add("STC " + (int) term1.valorChar);              }              auxilar.addAll(term2.listado);              auxilar.add("GTE");              terfin.listado = auxilar;            }            else if (term2.constante && !estado) //term1 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              if (term1.tipo == tipo_variable.ENTERO)              {                auxilar.add("STC " + term2.valorEnt);              }              else              {                auxilar.add("STC " + (int) term2.valorChar);              }              auxilar.add("GTE");              terfin.listado = auxilar;            }            else //term1 y term 2 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              auxilar.addAll(term2.listado);              auxilar.add("GTE");              terfin.listado = auxilar;            }          }          else if (tk.image.equals("<>"))          {            if (term1.tipo != tipo_variable.ENTERO && term1.tipo != tipo_variable.CARACTER)            {              errorSemantico("Error en operador relacional, se esperaba ENTERO O CARACTER[" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;            }            else if (term1.constante && term2.constante && !estado)            {              terfin.constante = true;              terfin.tipo = tipo_variable.BOOLEANO;              if (term1.tipo == tipo_variable.ENTERO)              {                terfin.valorBool = term1.valorEnt != term2.valorEnt;              }              else              {                terfin.valorBool = term1.valorChar != term2.valorChar;              }            }            else if (term1.constante && !estado) //term2 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              if (term1.tipo == tipo_variable.ENTERO)              {                auxilar.add("STC " + term1.valorEnt);              }              else              {                auxilar.add("STC " + (int) term1.valorChar);              }              auxilar.addAll(term2.listado);              auxilar.add("NEQ");              terfin.listado = auxilar;            }            else if (term2.constante && !estado) //term1 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              if (term1.tipo == tipo_variable.ENTERO)              {                auxilar.add("STC " + term2.valorEnt);              }              else              {                auxilar.add("STC " + (int) term2.valorChar);              }              auxilar.add("NEQ");              terfin.listado = auxilar;            }            else //term1 y term 2 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              auxilar.addAll(term2.listado);              auxilar.add("NEQ");              terfin.listado = auxilar;            }          }          else          {            errorSemantico("Error Supremo(108), Codigo Incorrecto [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");          }        }        else if ((term1.tipo == tipo_variable.DESCONOCIDO) && (term2.tipo == tipo_variable.DESCONOCIDO))        { //LOS 2 DESCONOCIDOS  PETADO NO HACE FALTA GENEAR CODIGO          terfin.tipo = tipo_variable.DESCONOCIDO;          terfin.constante = false;        }        else        {          errorSemantico("Error Supremo(109), Codigo Incorrecto [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");        }      }    )?    {      return terfin;    }  )}Token lista_escribibles(Token tk,boolean estado) :{  ArrayList < RegistroFactor > lista = null;}{  (    lista = lista_expresiones(estado)  )  {    for (int i = 0; i < lista.size(); i++)    {      if (lista.get(i).tipo == tipo_variable.BOOLEANO)      {        errorSemantico("No se pueden escribir booleanos [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");      }      else if (lista.get(i).tipo == tipo_variable.ENTERO)      {        if (lista.get(i).constante && !estado)        {          generarCodigo("STC " + lista.get(i).valorEnt);        }        else        {          generarCodigo(lista.get(i).listado);        }        generarCodigo("WRT 1");      }      else if (lista.get(i).tipo == tipo_variable.CARACTER)      {        if (lista.get(i).constante && !estado)        {          generarCodigo("STC " + (int) lista.get(i).valorChar);        }        else        {          generarCodigo(lista.get(i).listado);        }        generarCodigo("WRT 0");      }      else if (lista.get(i).tipo == tipo_variable.CADENA)      {        if (lista.get(i).constante)        {          char [ ] c_arr = lista.get(i).valorCadena.toCharArray();          for (int j = 1; j < c_arr.length - 1; j++)          {            generarCodigo("STC " + (int) c_arr [ j ]);            generarCodigo("WRT 0");          }        }        else        {          errorSemantico("Error Supremo(110), Codigo Incorrecto [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");        }      }    }  }  {    return tk;  }}/* termino::= factor ( operador_multiplicativo factor )**/RegistroFactor termino(boolean estado) :{  RegistroFactor term1, term2 = null;  RegistroFactor terfin = null;  Token tk = null;}{  (    term1 = factor(estado)    {      terfin = term1;    }    (      tk = operador_multiplicativo() term2 = factor(estado)      {        terfin = new RegistroFactor();        if ((term1.tipo != tipo_variable.DESCONOCIDO) && (term2.tipo != tipo_variable.DESCONOCIDO) && (term1.tipo != term2.tipo)) //TIPO INCORRECTO        {          errorSemantico("Los operandos deben ser del mismo tipo [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");          terfin.tipo = tipo_variable.DESCONOCIDO;          terfin.constante = false;        }        else if ((term1.tipo != tipo_variable.DESCONOCIDO) && (term2.tipo != tipo_variable.DESCONOCIDO) && (term1.tipo == term2.tipo)) //AMBOS OPERANDOS DEL MISMO TIPO         {          if (tk.image.equals("*"))          {            if (term1.tipo != tipo_variable.ENTERO)            {              errorSemantico("Error en operador multiplicativo, se esperaba ENTERO [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");              terfin.tipo = tipo_variable.ENTERO;              terfin.constante = false;            }            else if (term1.constante && term2.constante && !estado) //ENTERO '*' ENTERO            {              terfin.tipo = tipo_variable.ENTERO;              terfin.valorEnt = term1.valorEnt * term2.valorEnt;              term1.valorEnt = terfin.valorEnt;              terfin.constante = true;            }            else if (term1.constante && !estado) //term2 valor desconocido            {              terfin.tipo = tipo_variable.ENTERO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.add("STC " + term1.valorEnt);              auxilar.addAll(term2.listado);              auxilar.add("TMS");              terfin.listado = auxilar;              term1.constante = false;              term1.listado = auxilar;            }            else if (term2.constante && !estado) //term1 valor desconocido            {              terfin.tipo = tipo_variable.ENTERO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              auxilar.add("STC " + term2.valorEnt);              auxilar.add("TMS");              terfin.listado = auxilar;              term1.listado = auxilar;            }            else //term1 y term 2 valor desconocido            {              terfin.tipo = tipo_variable.ENTERO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              auxilar.addAll(term2.listado);              auxilar.add("TMS");              terfin.listado = auxilar;              term1.listado = auxilar;            }          }          else if (tk.image.equals("/") || tk.image.equals("div") || tk.image.equals("DIV"))          {            if (term1.tipo != tipo_variable.ENTERO)            {              errorSemantico("Error en operador multiplicativo, se esperaba ENTERO [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");            }            else if (term1.constante && term2.constante && !estado) //ENTERO '-' ENTERO            {              terfin.valorEnt = term1.valorEnt / term2.valorEnt;              terfin.tipo = tipo_variable.ENTERO;              term1.valorEnt = terfin.valorEnt;              terfin.constante = true;            }            else if (term1.constante && !estado) //term2 valor desconocido            {              terfin.tipo = tipo_variable.ENTERO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.add("STC " + term1.valorEnt);              auxilar.addAll(term2.listado);              auxilar.add("DIV");              terfin.listado = auxilar;              term1.constante = false;              term1.listado = auxilar;            }            else if (term2.constante && !estado) //term1 valor desconocido            {              terfin.tipo = tipo_variable.ENTERO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              auxilar.add("STC " + term2.valorEnt);              auxilar.add("DIV");              terfin.listado = auxilar;              term1.listado = auxilar;            }            else //term1 y term 2 valor desconocido            {              terfin.tipo = tipo_variable.ENTERO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              auxilar.addAll(term2.listado);              auxilar.add("DIV");              terfin.listado = auxilar;              term1.listado = auxilar;            }          }          else if (tk.image.equals("mod") || tk.image.equals("MOD"))          {            if (term1.tipo != tipo_variable.ENTERO)            {              errorSemantico("Error en operador multiplicativo, se esperaba ENTERO [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");            }            else if (term1.constante && term2.constante && !estado) //ENTERO 'mod' ENTERO            {              terfin.valorEnt = term1.valorEnt % term2.valorEnt;              terfin.tipo = tipo_variable.ENTERO;              term1.valorEnt = terfin.valorEnt;              terfin.constante = true;            }            else if (term1.constante && !estado) //term2 valor desconocido            {              terfin.tipo = tipo_variable.ENTERO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.add("STC " + term1.valorEnt);              auxilar.addAll(term2.listado);              auxilar.add("MOD");              terfin.listado = auxilar;              term1.constante = false;              term1.listado = auxilar;            }            else if (term2.constante && !estado) //term1 valor desconocido            {              terfin.tipo = tipo_variable.ENTERO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              auxilar.add("STC " + term2.valorEnt);              auxilar.add("MOD");              terfin.listado = auxilar;              term1.listado = auxilar;            }            else //term1 y term 2 valor desconocido            {              terfin.tipo = tipo_variable.ENTERO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              auxilar.addAll(term2.listado);              auxilar.add("MOD");              terfin.listado = auxilar;              term1.listado = auxilar;            }          }          else if (tk.image.equals("and") || tk.image.equals("AND"))          {            if (term1.tipo != tipo_variable.BOOLEANO)            {              errorSemantico("Error en operador multiplicativo, se esperaba BOOLEANO [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;            }            else if (term1.constante && term2.constante && !estado) //BOOLEANO 'and' BOOLEANO            {              terfin.constante = true;              terfin.tipo = tipo_variable.BOOLEANO;              terfin.valorBool = term1.valorBool & term2.valorBool;              term1.valorBool = terfin.valorBool;            }            else if (term1.constante && !estado) //term2 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              if (term1.valorBool)              {                auxilar.add("STC 1");              }              else              {                auxilar.add("STC 0");              }              auxilar.addAll(term2.listado);              auxilar.add("AND");              terfin.listado = auxilar;              term1.constante = false;              term1.listado = auxilar;            }            else if (term2.constante && !estado) //term1 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              if (term2.valorBool)              {                auxilar.add("STC 1");              }              else              {                auxilar.add("STC 0");              }              auxilar.add("AND");              terfin.listado = auxilar;              term1.listado = auxilar;            }            else //term1 y term 2 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              auxilar.addAll(term2.listado);              auxilar.add("AND");              terfin.listado = auxilar;              term1.listado = auxilar;            }          }          else          {            errorSemantico("Error Supremo(106), Codigo Incorrecto [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");          }        }        else if ((term1.tipo == tipo_variable.DESCONOCIDO) && (term2.tipo == tipo_variable.DESCONOCIDO))        { //LOS 2 DESCONOCIDOS  PETADO NO HACE FALTA GENEAR CODIGO          terfin.tipo = tipo_variable.DESCONOCIDO;          terfin.constante = false;        }        else        {          errorSemantico("Error Supremo(107), Codigo Incorrecto [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");        }      }    )*    {      return terfin;    }  )}/* expresion_simple::= termino ( operador_aditivo termino )**/RegistroFactor expresion_simple(boolean estado) :{  RegistroFactor term1, term2 = null;  RegistroFactor terfin = null;  Token tk = null;}{  (    term1 = termino(estado)    {      terfin = term1;    }    (      tk = operador_aditivo() term2 = termino(estado)      {        terfin = new RegistroFactor();        if ((term1.tipo != tipo_variable.DESCONOCIDO) && (term2.tipo != tipo_variable.DESCONOCIDO) && (term1.tipo != term2.tipo)) ////TIPO INCORRECTO        {          errorSemantico("Los operandos deben ser del mismo tipo [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");          terfin.tipo = tipo_variable.DESCONOCIDO;          terfin.constante = false;        }        else if ((term1.tipo != tipo_variable.DESCONOCIDO) && (term2.tipo != tipo_variable.DESCONOCIDO) && (term1.tipo == term2.tipo)) //AMBOS OPERANDOS DEL MISMO TIPO         {          if (tk.image.equals("+"))          {            if (term1.tipo != tipo_variable.ENTERO)            {              errorSemantico("Error en operador aditivo, se esperaba ENTERO [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");              terfin.tipo = tipo_variable.ENTERO;              terfin.constante = false;            }            else if (term1.constante && term2.constante && !estado) //ENTERO '+' ENTERO            {              terfin.tipo = tipo_variable.ENTERO;              terfin.valorEnt = term1.valorEnt + term2.valorEnt;              term1.valorEnt = terfin.valorEnt;              terfin.constante = true;            }            else if (term1.constante && !estado) //term2 valor desconocido            {              terfin.tipo = tipo_variable.ENTERO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.add("STC " + term1.valorEnt);              auxilar.addAll(term2.listado);              auxilar.add("PLUS");              terfin.listado = auxilar;              term1.listado = auxilar;              term1.constante = false;            }            else if (term2.constante && !estado) //term1 valor desconocido            {              terfin.tipo = tipo_variable.ENTERO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              auxilar.add("STC " + term2.valorEnt);              auxilar.add("PLUS");              terfin.listado = auxilar;              term1.listado = auxilar;            }            else //term1 y term 2 valor desconocido            {              terfin.tipo = tipo_variable.ENTERO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              auxilar.addAll(term2.listado);              auxilar.add("PLUS");              terfin.listado = auxilar;              term1.listado = auxilar;            }          }          else if (tk.image.equals("-"))          {            if (term1.tipo != tipo_variable.ENTERO)            {              errorSemantico("Error en operador aditivo, se esperaba ENTERO [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");            }            else if (term1.constante && term2.constante && !estado) //ENTERO '-' ENTERO            {              terfin.valorEnt = term1.valorEnt - term2.valorEnt;              terfin.tipo = tipo_variable.ENTERO;              term1.valorEnt = terfin.valorEnt;              terfin.constante = true;            }            else if (term1.constante && !estado) //term2 valor desconocido            {              terfin.tipo = tipo_variable.ENTERO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.add("STC " + term1.valorEnt);              auxilar.addAll(term2.listado);              auxilar.add("SBT");              terfin.listado = auxilar;              term1.listado = auxilar;              term1.constante = false;            }            else if (term2.constante && !estado) //term1 valor desconocido            {              terfin.tipo = tipo_variable.ENTERO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              auxilar.add("STC " + term2.valorEnt);              auxilar.add("SBT");              terfin.listado = auxilar;              term1.listado = auxilar;            }            else //term1 y term 2 valor desconocido            {              terfin.tipo = tipo_variable.ENTERO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              auxilar.addAll(term2.listado);              auxilar.add("SBT");              terfin.listado = auxilar;              term1.listado = auxilar;            }          }          else if (tk.image.equals("or") || tk.image.equals("OR"))          {            if (term1.tipo != tipo_variable.BOOLEANO)            {              errorSemantico("Error en operador aditivo, se esperaba BOOLEANO [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;            }            else if (term1.constante && term2.constante && !estado) //BOOLEANO 'or' BOOLEANO            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.valorBool = term1.valorBool            | term2.valorBool;              term1.valorBool = terfin.valorBool;              terfin.constante = true;            }            else if (term1.constante && !estado) //term2 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              if (term1.valorBool)              {                auxilar.add("STC 1");              }              else              {                auxilar.add("STC 0");              }              auxilar.addAll(term2.listado);              auxilar.add("OR");              terfin.listado = auxilar;              term1.constante = false;              term1.listado = auxilar;            }            else if (term2.constante && !estado) //term1 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              if (term2.valorBool)              {                auxilar.add("STC 1");              }              else              {                auxilar.add("STC 0");              }              auxilar.add("OR");              terfin.listado = auxilar;              term1.listado = auxilar;            }            else //term1 y term 2 valor desconocido            {              terfin.tipo = tipo_variable.BOOLEANO;              terfin.constante = false;              ArrayList < String > auxilar = new ArrayList < String > ();              auxilar.addAll(term1.listado);              auxilar.addAll(term2.listado);              auxilar.add("OR");              terfin.listado = auxilar;              term1.listado = auxilar;            }          }          else          {            errorSemantico("Error Supremo(101), Codigo Incorrecto [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");          }        }        else if ((term1.tipo == tipo_variable.DESCONOCIDO) && (term2.tipo == tipo_variable.DESCONOCIDO))        { //LOS 2 DESCONOCIDOS  PETADO NO HACE FALTA GENEAR CODIGO          terfin.tipo = tipo_variable.DESCONOCIDO;          terfin.constante = false;        }        else        {          errorSemantico("Error Supremo(102), Codigo Incorrecto [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");        }      }    )*    {      return terfin;    }  )}Token operador_multiplicativo() :{  Token tk = null;}{  (    tk = < DIV >  | tk = < MUL >  | tk = < tAND >  | tk = < tMOD >  | tk = < tDIV >  )  {    return tk;  }}Token operador_aditivo() :{  Token tk = null;}{  (    tk = < MAS >  | tk = < MENOS >  | tk = < tOR >  )  {    return tk;  }}Token operador_relacional() :{  Token tk = null;}{  (    tk = < tMAYOR >  | tk = < tMENOR >  | tk = < tIGUAL >  | tk = < tMAI >  | tk = < tMEI >  | tk = < tNI >  )  {    return tk;  }}/*factor::= 	 <tNOT> factor| 	 "-” factor|    "(" expresion ")" |    <tENTACAR> "(" expresion ")" |    <tCARAENT> "(" expresion ")" |    <tCONSTENTERA> |    <tCONSTCHAR> |    <tCONSTCAD> |    <tTRUE> |    <tFALSE> |    <tIDENTIFICADOR> */RegistroFactor factor(boolean estado) :{  Token tk = null;  RegistroFactor tpFactor = new RegistroFactor();  RegistroFactor tpAuxi = new RegistroFactor();  ArrayList < String > auxilar = new ArrayList < String > ();  Simbolo s1;}{  (    tk = < tNOT > tpFactor = factor(estado)    {      if (tpFactor.tipo != tipo_variable.BOOLEANO && tpFactor.tipo != tipo_variable.DESCONOCIDO)      {        errorSemantico("Tipo incompatible. Se esperaba booleano [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");        tpFactor.tipo = tipo_variable.BOOLEANO;        tpFactor.constante = false;      }      else if (tpFactor.tipo == tipo_variable.BOOLEANO && tpFactor.constante && !estado)      {        tpFactor.constante = true;        tpFactor.valorBool = !tpFactor.valorBool;        tpFactor.tipo = tipo_variable.BOOLEANO;      }      else if (tpFactor.tipo == tipo_variable.DESCONOCIDO || tpFactor.tipo == tipo_variable.BOOLEANO)      {        tpFactor.constante = false;        tpFactor.tipo = tipo_variable.BOOLEANO;        tpFactor.listado.add("NGB");      }      else      {        errorSemantico("Error Supremo(103), Codigo Incorrecto [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");      }      return tpFactor;    }  | "(" tpFactor = expresion(estado) ")"    {      return tpFactor;    }  | tk = < tENTACAR > "(" tpAuxi = expresion(estado) ")"    {      if ((tpAuxi.tipo != tipo_variable.ENTERO) && (tpAuxi.tipo != tipo_variable.DESCONOCIDO))      {        errorSemantico("Tipo incompatible. Se esperaba entero [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");        tpFactor.tipo = tipo_variable.CARACTER;        tpFactor.constante = false;      }      else if (tpAuxi.tipo == tipo_variable.ENTERO && tpAuxi.constante)      {         tpFactor.constante = true;        tpFactor.tipo = tipo_variable.CARACTER;        tpFactor.valorChar = (char) tpAuxi.valorEnt;         tpFactor.variable = tpAuxi.variable;         tpFactor.listado = tpAuxi.listado;      }      else if (tpAuxi.tipo == tipo_variable.DESCONOCIDO || tpAuxi.tipo == tipo_variable.ENTERO)      {        tpFactor.tipo = tipo_variable.CARACTER;        tpFactor.variable = tpAuxi.variable;        tpFactor.listado = tpAuxi.listado;      }      else      {        errorSemantico("Error Supremo(104), Codigo Incorrecto [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");      }      return tpFactor;    }  | tk = < tCARAENT > "(" tpAuxi = expresion(estado) ")"    {      if (tpAuxi.tipo != tipo_variable.CARACTER && tpAuxi.tipo != tipo_variable.DESCONOCIDO)      {        errorSemantico("Tipo incompatible. Se esperaba caracter [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");        tpFactor.tipo = tipo_variable.ENTERO;        tpFactor.constante = false;      }      else if (tpAuxi.tipo == tipo_variable.CARACTER && tpAuxi.constante)      {          tpFactor.constante = true;        tpFactor.tipo = tipo_variable.ENTERO;        tpFactor.valorEnt = (int) tpAuxi.valorChar;        tpFactor.variable = tpAuxi.variable;        tpFactor.listado = tpAuxi.listado;      }      else if (tpAuxi.tipo == tipo_variable.DESCONOCIDO || tpAuxi.tipo == tipo_variable.CARACTER)      {        tpFactor.tipo = tipo_variable.ENTERO;       tpFactor.variable = tpAuxi.variable;       tpFactor.listado = tpAuxi.listado;      }      else      {        errorSemantico("Error Supremo(105), Codigo Incorrecto [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");      }      return tpFactor;    }  | tk = < tIDENTIFICADOR >    {      s1 = tablaSim.buscar_simbolo(tk.image);      if (s1 == null)      {        errorSemantico("Identificador Desconocido [" + tk.beginLine + "," + tk.beginColumn + "] " + "Token: <" + tk.image + ">");        tpFactor.tipo = tipo_variable.DESCONOCIDO;        tpFactor.constante = false;      }      else      {        tpFactor = s1.getFactor();        if (tpFactor == null)        {          tpFactor = new RegistroFactor();          tpFactor.tipo = s1.getVariable();        }        tpFactor.variable = true;        tpFactor.par = s1.getParametro();        if (!tpFactor.constante || estado) //Si no sabemos el valor en compilacion        {          auxilar.add("SRF " + (nivel - s1.getNivel()) + " " + s1.getDir());          auxilar.add("DRF");          tpFactor.listado = auxilar;        }      }      return tpFactor;    }  | tk = < tCONSTENTERA >    {      if (estado)      {        tpFactor.constante = false;        auxilar.add("STC " + Integer.parseInt(tk.image));        tpFactor.listado = auxilar;      }      else      {        /*Propagar la informacion de la variable */        tpFactor.valorEnt = Integer.parseInt(tk.image);        tpFactor.constante = true;      }      tpFactor.tipo = tipo_variable.ENTERO;      return tpFactor;    }  | tk = < tCONSTCHAR >    {      if (estado)      {        tpFactor.constante = false;        auxilar.add("STC " + (int) tk.image.charAt(1));        tpFactor.listado = auxilar;      }      else      {        /*Propagar la informacion de la variable */        tpFactor.valorChar = (tk.image).charAt(1);        tpFactor.constante = true;      }      tpFactor.tipo = tipo_variable.CARACTER;      return tpFactor;    }  | tk = < tCONSTCAD >    {      /*Propagar la informacion de la variable */      tpFactor.tipo = tipo_variable.CADENA;      tpFactor.valorCadena = (tk.image);      tpFactor.constante = true;      return tpFactor;    }  | tk = < tTRUE >    {      if (estado)      {        tpFactor.constante = false;        auxilar.add("STC 1");        tpFactor.listado = auxilar;      }      else      {        /*Propagar la informacion de la variable */        tpFactor.valorBool = true;        tpFactor.constante = true;      }      tpFactor.tipo = tipo_variable.BOOLEANO;      return tpFactor;    }  | tk = < tFALSE >    {      if (estado) //Si es un while      {        tpFactor.constante = false;        auxilar.add("STC 0");        tpFactor.listado = auxilar;      }      else      {        /*Propagar la informacion de la variable */        tpFactor.valorBool = false;        tpFactor.constante = true;      }      tpFactor.tipo = tipo_variable.BOOLEANO;      return tpFactor;    }  )}
